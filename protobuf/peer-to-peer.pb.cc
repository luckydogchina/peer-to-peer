// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: peer-to-peer.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "peer-to-peer.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace p2p {
class ConnectDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Connect> {
} _Connect_default_instance_;
class Connect_rDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Connect_r> {
} _Connect_r_default_instance_;
class GetUserOnline_rDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<GetUserOnline_r> {
} _GetUserOnline_r_default_instance_;
class InfoDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Info> {
} _Info_default_instance_;
class Info_rDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Info_r> {
} _Info_r_default_instance_;
class Hello_rDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Hello_r> {
} _Hello_r_default_instance_;
class PacketDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Packet> {
} _Packet_default_instance_;
class RPacketDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<RPacket> {
} _RPacket_default_instance_;
class AddressDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Address> {
} _Address_default_instance_;
class InitiativeDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Initiative> {
} _Initiative_default_instance_;

namespace protobuf_peer_2dto_2dpeer_2eproto {


namespace {

::google::protobuf::Metadata file_level_metadata[10];
const ::google::protobuf::EnumDescriptor* file_level_enum_descriptors[3];

}  // namespace

PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::ParseTableField
    const TableStruct::entries[] = {
  {0, 0, 0, ::google::protobuf::internal::kInvalidMask, 0, 0},
};

PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::AuxillaryParseTableField
    const TableStruct::aux[] = {
  ::google::protobuf::internal::AuxillaryParseTableField(),
};
PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::ParseTable const
    TableStruct::schema[] = {
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
};

const ::google::protobuf::uint32 TableStruct::offsets[] = {
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Connect, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Connect, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Connect, peer_),
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Connect_r, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Connect_r, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Connect_r, t_),
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetUserOnline_r, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetUserOnline_r, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetUserOnline_r, user_online_),
  ~0u,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Info, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Info, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Info, peer_),
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Info_r, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Info_r, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Info_r, t_),
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Hello_r, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Hello_r, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Hello_r, t_),
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Packet, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Packet, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Packet, api_id_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Packet, user_id_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Packet, cnt_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Packet, inf_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Packet, version_),
  4,
  0,
  2,
  3,
  1,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RPacket, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RPacket, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RPacket, api_id_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RPacket, cnt_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RPacket, guonline_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RPacket, in_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RPacket, hello_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RPacket, version_),
  5,
  1,
  2,
  3,
  4,
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Address, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Address, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Address, id_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Address, addr_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Address, port_),
  1,
  0,
  2,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Initiative, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Initiative, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Initiative, t_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Initiative, adr_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Initiative, version_),
  2,
  1,
  0,
};

static const ::google::protobuf::internal::MigrationSchema schemas[] = {
  { 0, 6, sizeof(Connect)},
  { 7, 13, sizeof(Connect_r)},
  { 14, 20, sizeof(GetUserOnline_r)},
  { 21, 27, sizeof(Info)},
  { 28, 34, sizeof(Info_r)},
  { 35, 41, sizeof(Hello_r)},
  { 42, 52, sizeof(Packet)},
  { 57, 68, sizeof(RPacket)},
  { 74, 82, sizeof(Address)},
  { 85, 93, sizeof(Initiative)},
};

static ::google::protobuf::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::google::protobuf::Message*>(&_Connect_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_Connect_r_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_GetUserOnline_r_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_Info_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_Info_r_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_Hello_r_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_Packet_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_RPacket_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_Address_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_Initiative_default_instance_),
};

namespace {

void protobuf_AssignDescriptors() {
  AddDescriptors();
  ::google::protobuf::MessageFactory* factory = NULL;
  AssignDescriptors(
      "peer-to-peer.proto", schemas, file_default_instances, TableStruct::offsets, factory,
      file_level_metadata, file_level_enum_descriptors, NULL);
}

void protobuf_AssignDescriptorsOnce() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &protobuf_AssignDescriptors);
}

void protobuf_RegisterTypes(const ::std::string&) GOOGLE_ATTRIBUTE_COLD;
void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::internal::RegisterAllTypes(file_level_metadata, 10);
}

}  // namespace

void TableStruct::Shutdown() {
  _Connect_default_instance_.Shutdown();
  delete file_level_metadata[0].reflection;
  _Connect_r_default_instance_.Shutdown();
  delete file_level_metadata[1].reflection;
  _GetUserOnline_r_default_instance_.Shutdown();
  delete file_level_metadata[2].reflection;
  _Info_default_instance_.Shutdown();
  delete file_level_metadata[3].reflection;
  _Info_r_default_instance_.Shutdown();
  delete file_level_metadata[4].reflection;
  _Hello_r_default_instance_.Shutdown();
  delete file_level_metadata[5].reflection;
  _Packet_default_instance_.Shutdown();
  delete file_level_metadata[6].reflection;
  Packet::_default_version_.Shutdown();
  _RPacket_default_instance_.Shutdown();
  delete file_level_metadata[7].reflection;
  RPacket::_default_version_.Shutdown();
  _Address_default_instance_.Shutdown();
  delete file_level_metadata[8].reflection;
  _Initiative_default_instance_.Shutdown();
  delete file_level_metadata[9].reflection;
  Initiative::_default_version_.Shutdown();
}

void TableStruct::InitDefaultsImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::internal::InitProtobufDefaults();
  _Connect_default_instance_.DefaultConstruct();
  _Connect_r_default_instance_.DefaultConstruct();
  _GetUserOnline_r_default_instance_.DefaultConstruct();
  _Info_default_instance_.DefaultConstruct();
  _Info_r_default_instance_.DefaultConstruct();
  _Hello_r_default_instance_.DefaultConstruct();
  Packet::_default_version_.DefaultConstruct();
  *Packet::_default_version_.get_mutable() = ::std::string("0.1.0", 5);
  _Packet_default_instance_.DefaultConstruct();
  RPacket::_default_version_.DefaultConstruct();
  *RPacket::_default_version_.get_mutable() = ::std::string("0.1.0", 5);
  _RPacket_default_instance_.DefaultConstruct();
  _Address_default_instance_.DefaultConstruct();
  Initiative::_default_version_.DefaultConstruct();
  *Initiative::_default_version_.get_mutable() = ::std::string("0.1.0", 5);
  _Initiative_default_instance_.DefaultConstruct();
  _Packet_default_instance_.get_mutable()->cnt_ = const_cast< ::p2p::Connect*>(
      ::p2p::Connect::internal_default_instance());
  _Packet_default_instance_.get_mutable()->inf_ = const_cast< ::p2p::Info*>(
      ::p2p::Info::internal_default_instance());
  _RPacket_default_instance_.get_mutable()->cnt_ = const_cast< ::p2p::Connect_r*>(
      ::p2p::Connect_r::internal_default_instance());
  _RPacket_default_instance_.get_mutable()->guonline_ = const_cast< ::p2p::GetUserOnline_r*>(
      ::p2p::GetUserOnline_r::internal_default_instance());
  _RPacket_default_instance_.get_mutable()->in_ = const_cast< ::p2p::Info_r*>(
      ::p2p::Info_r::internal_default_instance());
  _RPacket_default_instance_.get_mutable()->hello_ = const_cast< ::p2p::Hello_r*>(
      ::p2p::Hello_r::internal_default_instance());
  _Initiative_default_instance_.get_mutable()->adr_ = const_cast< ::p2p::Address*>(
      ::p2p::Address::internal_default_instance());
}

void InitDefaults() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &TableStruct::InitDefaultsImpl);
}
void AddDescriptorsImpl() {
  InitDefaults();
  static const char descriptor[] = {
      "\n\022peer-to-peer.proto\022\003p2p\"\027\n\007Connect\022\014\n\004"
      "peer\030\001 \002(\t\"0\n\tConnect_r\022#\n\001t\030\001 \002(\0162\017.p2p"
      ".StatusType:\007SUCCESS\"&\n\017GetUserOnline_r\022"
      "\023\n\013user_online\030\001 \003(\t\"\024\n\004Info\022\014\n\004peer\030\001 \002"
      "(\t\"-\n\006Info_r\022#\n\001t\030\001 \002(\0162\017.p2p.StatusType"
      ":\007SUCCESS\".\n\007Hello_r\022#\n\001t\030\001 \002(\0162\017.p2p.St"
      "atusType:\007SUCCESS\"\201\001\n\006Packet\022\033\n\006api_id\030\001"
      " \002(\0162\013.p2p.API_ID\022\017\n\007user_id\030\002 \002(\t\022\031\n\003cn"
      "t\030\003 \001(\0132\014.p2p.Connect\022\026\n\003inf\030\004 \001(\0132\t.p2p"
      ".Info\022\026\n\007version\030\005 \001(\t:\0050.1.0\"\271\001\n\007RPacke"
      "t\022\033\n\006api_id\030\001 \002(\0162\013.p2p.API_ID\022\033\n\003cnt\030\002 "
      "\001(\0132\016.p2p.Connect_r\022&\n\010guonline\030\003 \001(\0132\024."
      "p2p.GetUserOnline_r\022\027\n\002in\030\004 \001(\0132\013.p2p.In"
      "fo_r\022\033\n\005hello\030\005 \001(\0132\014.p2p.Hello_r\022\026\n\007ver"
      "sion\030\006 \001(\t:\0050.1.0\"1\n\007Address\022\n\n\002id\030\004 \002(\t"
      "\022\014\n\004addr\030\002 \002(\t\022\014\n\004port\030\003 \002(\005\"h\n\nInitiati"
      "ve\022\'\n\001t\030\001 \002(\0162\023.p2p.InitiativeType:\007ADDR"
      "ESS\022\031\n\003adr\030\002 \001(\0132\014.p2p.Address\022\026\n\007versio"
      "n\030\003 \001(\t:\0050.1.0*U\n\006API_ID\022\021\n\rGETUSERONLIN"
      "E\020\001\022\013\n\007CONNECT\020\002\022\010\n\004INFO\020\003\022\013\n\007OFFLINE\020\004\022"
      "\t\n\005HEART\020\005\022\t\n\005HELLO\020\006*a\n\nStatusType\022\013\n\007S"
      "UCCESS\020\001\022\013\n\007FAILURE\020\002\022\t\n\005READY\020\003\022\t\n\005CLOS"
      "E\020\004\022\013\n\007RUNNING\020\005\022\013\n\007NOEXIST\020\006\022\t\n\005EXIST\020\007"
      "*\035\n\016InitiativeType\022\013\n\007ADDRESS\020\001"
  };
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
      descriptor, 951);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "peer-to-peer.proto", &protobuf_RegisterTypes);
  ::google::protobuf::internal::OnShutdown(&TableStruct::Shutdown);
}

void AddDescriptors() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &AddDescriptorsImpl);
}
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer {
  StaticDescriptorInitializer() {
    AddDescriptors();
  }
} static_descriptor_initializer;

}  // namespace protobuf_peer_2dto_2dpeer_2eproto

const ::google::protobuf::EnumDescriptor* API_ID_descriptor() {
  protobuf_peer_2dto_2dpeer_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_peer_2dto_2dpeer_2eproto::file_level_enum_descriptors[0];
}
bool API_ID_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* StatusType_descriptor() {
  protobuf_peer_2dto_2dpeer_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_peer_2dto_2dpeer_2eproto::file_level_enum_descriptors[1];
}
bool StatusType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* InitiativeType_descriptor() {
  protobuf_peer_2dto_2dpeer_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_peer_2dto_2dpeer_2eproto::file_level_enum_descriptors[2];
}
bool InitiativeType_IsValid(int value) {
  switch (value) {
    case 1:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Connect::kPeerFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Connect::Connect()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_peer_2dto_2dpeer_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:p2p.Connect)
}
Connect::Connect(const Connect& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  peer_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_peer()) {
    peer_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.peer_);
  }
  // @@protoc_insertion_point(copy_constructor:p2p.Connect)
}

void Connect::SharedCtor() {
  _cached_size_ = 0;
  peer_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

Connect::~Connect() {
  // @@protoc_insertion_point(destructor:p2p.Connect)
  SharedDtor();
}

void Connect::SharedDtor() {
  peer_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void Connect::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Connect::descriptor() {
  protobuf_peer_2dto_2dpeer_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_peer_2dto_2dpeer_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Connect& Connect::default_instance() {
  protobuf_peer_2dto_2dpeer_2eproto::InitDefaults();
  return *internal_default_instance();
}

Connect* Connect::New(::google::protobuf::Arena* arena) const {
  Connect* n = new Connect;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Connect::Clear() {
// @@protoc_insertion_point(message_clear_start:p2p.Connect)
  if (has_peer()) {
    GOOGLE_DCHECK(!peer_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
    (*peer_.UnsafeRawStringPointer())->clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Connect::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:p2p.Connect)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string peer = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_peer()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->peer().data(), this->peer().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "p2p.Connect.peer");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:p2p.Connect)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:p2p.Connect)
  return false;
#undef DO_
}

void Connect::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:p2p.Connect)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string peer = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->peer().data(), this->peer().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "p2p.Connect.peer");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->peer(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:p2p.Connect)
}

::google::protobuf::uint8* Connect::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2p.Connect)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string peer = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->peer().data(), this->peer().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "p2p.Connect.peer");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->peer(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2p.Connect)
  return target;
}

size_t Connect::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2p.Connect)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // required string peer = 1;
  if (has_peer()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->peer());
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Connect::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:p2p.Connect)
  GOOGLE_DCHECK_NE(&from, this);
  const Connect* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Connect>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:p2p.Connect)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:p2p.Connect)
    MergeFrom(*source);
  }
}

void Connect::MergeFrom(const Connect& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:p2p.Connect)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_peer()) {
    set_has_peer();
    peer_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.peer_);
  }
}

void Connect::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:p2p.Connect)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Connect::CopyFrom(const Connect& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2p.Connect)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Connect::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void Connect::Swap(Connect* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Connect::InternalSwap(Connect* other) {
  peer_.Swap(&other->peer_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Connect::GetMetadata() const {
  protobuf_peer_2dto_2dpeer_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_peer_2dto_2dpeer_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Connect

// required string peer = 1;
bool Connect::has_peer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Connect::set_has_peer() {
  _has_bits_[0] |= 0x00000001u;
}
void Connect::clear_has_peer() {
  _has_bits_[0] &= ~0x00000001u;
}
void Connect::clear_peer() {
  peer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_peer();
}
const ::std::string& Connect::peer() const {
  // @@protoc_insertion_point(field_get:p2p.Connect.peer)
  return peer_.GetNoArena();
}
void Connect::set_peer(const ::std::string& value) {
  set_has_peer();
  peer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:p2p.Connect.peer)
}
#if LANG_CXX11
void Connect::set_peer(::std::string&& value) {
  set_has_peer();
  peer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:p2p.Connect.peer)
}
#endif
void Connect::set_peer(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_peer();
  peer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:p2p.Connect.peer)
}
void Connect::set_peer(const char* value, size_t size) {
  set_has_peer();
  peer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:p2p.Connect.peer)
}
::std::string* Connect::mutable_peer() {
  set_has_peer();
  // @@protoc_insertion_point(field_mutable:p2p.Connect.peer)
  return peer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* Connect::release_peer() {
  // @@protoc_insertion_point(field_release:p2p.Connect.peer)
  clear_has_peer();
  return peer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void Connect::set_allocated_peer(::std::string* peer) {
  if (peer != NULL) {
    set_has_peer();
  } else {
    clear_has_peer();
  }
  peer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), peer);
  // @@protoc_insertion_point(field_set_allocated:p2p.Connect.peer)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Connect_r::kTFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Connect_r::Connect_r()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_peer_2dto_2dpeer_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:p2p.Connect_r)
}
Connect_r::Connect_r(const Connect_r& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  t_ = from.t_;
  // @@protoc_insertion_point(copy_constructor:p2p.Connect_r)
}

void Connect_r::SharedCtor() {
  _cached_size_ = 0;
  t_ = 1;
}

Connect_r::~Connect_r() {
  // @@protoc_insertion_point(destructor:p2p.Connect_r)
  SharedDtor();
}

void Connect_r::SharedDtor() {
}

void Connect_r::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Connect_r::descriptor() {
  protobuf_peer_2dto_2dpeer_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_peer_2dto_2dpeer_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Connect_r& Connect_r::default_instance() {
  protobuf_peer_2dto_2dpeer_2eproto::InitDefaults();
  return *internal_default_instance();
}

Connect_r* Connect_r::New(::google::protobuf::Arena* arena) const {
  Connect_r* n = new Connect_r;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Connect_r::Clear() {
// @@protoc_insertion_point(message_clear_start:p2p.Connect_r)
  t_ = 1;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Connect_r::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:p2p.Connect_r)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .p2p.StatusType t = 1 [default = SUCCESS];
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::p2p::StatusType_IsValid(value)) {
            set_t(static_cast< ::p2p::StatusType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:p2p.Connect_r)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:p2p.Connect_r)
  return false;
#undef DO_
}

void Connect_r::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:p2p.Connect_r)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .p2p.StatusType t = 1 [default = SUCCESS];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->t(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:p2p.Connect_r)
}

::google::protobuf::uint8* Connect_r::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2p.Connect_r)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .p2p.StatusType t = 1 [default = SUCCESS];
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->t(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2p.Connect_r)
  return target;
}

size_t Connect_r::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2p.Connect_r)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // required .p2p.StatusType t = 1 [default = SUCCESS];
  if (has_t()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->t());
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Connect_r::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:p2p.Connect_r)
  GOOGLE_DCHECK_NE(&from, this);
  const Connect_r* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Connect_r>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:p2p.Connect_r)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:p2p.Connect_r)
    MergeFrom(*source);
  }
}

void Connect_r::MergeFrom(const Connect_r& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:p2p.Connect_r)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_t()) {
    set_t(from.t());
  }
}

void Connect_r::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:p2p.Connect_r)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Connect_r::CopyFrom(const Connect_r& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2p.Connect_r)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Connect_r::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void Connect_r::Swap(Connect_r* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Connect_r::InternalSwap(Connect_r* other) {
  std::swap(t_, other->t_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Connect_r::GetMetadata() const {
  protobuf_peer_2dto_2dpeer_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_peer_2dto_2dpeer_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Connect_r

// required .p2p.StatusType t = 1 [default = SUCCESS];
bool Connect_r::has_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Connect_r::set_has_t() {
  _has_bits_[0] |= 0x00000001u;
}
void Connect_r::clear_has_t() {
  _has_bits_[0] &= ~0x00000001u;
}
void Connect_r::clear_t() {
  t_ = 1;
  clear_has_t();
}
::p2p::StatusType Connect_r::t() const {
  // @@protoc_insertion_point(field_get:p2p.Connect_r.t)
  return static_cast< ::p2p::StatusType >(t_);
}
void Connect_r::set_t(::p2p::StatusType value) {
  assert(::p2p::StatusType_IsValid(value));
  set_has_t();
  t_ = value;
  // @@protoc_insertion_point(field_set:p2p.Connect_r.t)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GetUserOnline_r::kUserOnlineFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GetUserOnline_r::GetUserOnline_r()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_peer_2dto_2dpeer_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:p2p.GetUserOnline_r)
}
GetUserOnline_r::GetUserOnline_r(const GetUserOnline_r& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      user_online_(from.user_online_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:p2p.GetUserOnline_r)
}

void GetUserOnline_r::SharedCtor() {
  _cached_size_ = 0;
}

GetUserOnline_r::~GetUserOnline_r() {
  // @@protoc_insertion_point(destructor:p2p.GetUserOnline_r)
  SharedDtor();
}

void GetUserOnline_r::SharedDtor() {
}

void GetUserOnline_r::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GetUserOnline_r::descriptor() {
  protobuf_peer_2dto_2dpeer_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_peer_2dto_2dpeer_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const GetUserOnline_r& GetUserOnline_r::default_instance() {
  protobuf_peer_2dto_2dpeer_2eproto::InitDefaults();
  return *internal_default_instance();
}

GetUserOnline_r* GetUserOnline_r::New(::google::protobuf::Arena* arena) const {
  GetUserOnline_r* n = new GetUserOnline_r;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void GetUserOnline_r::Clear() {
// @@protoc_insertion_point(message_clear_start:p2p.GetUserOnline_r)
  user_online_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool GetUserOnline_r::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:p2p.GetUserOnline_r)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated string user_online = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_user_online()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->user_online(this->user_online_size() - 1).data(),
            this->user_online(this->user_online_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "p2p.GetUserOnline_r.user_online");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:p2p.GetUserOnline_r)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:p2p.GetUserOnline_r)
  return false;
#undef DO_
}

void GetUserOnline_r::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:p2p.GetUserOnline_r)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string user_online = 1;
  for (int i = 0, n = this->user_online_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->user_online(i).data(), this->user_online(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "p2p.GetUserOnline_r.user_online");
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->user_online(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:p2p.GetUserOnline_r)
}

::google::protobuf::uint8* GetUserOnline_r::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2p.GetUserOnline_r)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string user_online = 1;
  for (int i = 0, n = this->user_online_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->user_online(i).data(), this->user_online(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "p2p.GetUserOnline_r.user_online");
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(1, this->user_online(i), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2p.GetUserOnline_r)
  return target;
}

size_t GetUserOnline_r::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2p.GetUserOnline_r)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // repeated string user_online = 1;
  total_size += 1 *
      ::google::protobuf::internal::FromIntSize(this->user_online_size());
  for (int i = 0, n = this->user_online_size(); i < n; i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->user_online(i));
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetUserOnline_r::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:p2p.GetUserOnline_r)
  GOOGLE_DCHECK_NE(&from, this);
  const GetUserOnline_r* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const GetUserOnline_r>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:p2p.GetUserOnline_r)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:p2p.GetUserOnline_r)
    MergeFrom(*source);
  }
}

void GetUserOnline_r::MergeFrom(const GetUserOnline_r& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:p2p.GetUserOnline_r)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  user_online_.MergeFrom(from.user_online_);
}

void GetUserOnline_r::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:p2p.GetUserOnline_r)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetUserOnline_r::CopyFrom(const GetUserOnline_r& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2p.GetUserOnline_r)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetUserOnline_r::IsInitialized() const {
  return true;
}

void GetUserOnline_r::Swap(GetUserOnline_r* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GetUserOnline_r::InternalSwap(GetUserOnline_r* other) {
  user_online_.InternalSwap(&other->user_online_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata GetUserOnline_r::GetMetadata() const {
  protobuf_peer_2dto_2dpeer_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_peer_2dto_2dpeer_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// GetUserOnline_r

// repeated string user_online = 1;
int GetUserOnline_r::user_online_size() const {
  return user_online_.size();
}
void GetUserOnline_r::clear_user_online() {
  user_online_.Clear();
}
const ::std::string& GetUserOnline_r::user_online(int index) const {
  // @@protoc_insertion_point(field_get:p2p.GetUserOnline_r.user_online)
  return user_online_.Get(index);
}
::std::string* GetUserOnline_r::mutable_user_online(int index) {
  // @@protoc_insertion_point(field_mutable:p2p.GetUserOnline_r.user_online)
  return user_online_.Mutable(index);
}
void GetUserOnline_r::set_user_online(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:p2p.GetUserOnline_r.user_online)
  user_online_.Mutable(index)->assign(value);
}
#if LANG_CXX11
void GetUserOnline_r::set_user_online(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:p2p.GetUserOnline_r.user_online)
  user_online_.Mutable(index)->assign(std::move(value));
}
#endif
void GetUserOnline_r::set_user_online(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  user_online_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:p2p.GetUserOnline_r.user_online)
}
void GetUserOnline_r::set_user_online(int index, const char* value, size_t size) {
  user_online_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:p2p.GetUserOnline_r.user_online)
}
::std::string* GetUserOnline_r::add_user_online() {
  // @@protoc_insertion_point(field_add_mutable:p2p.GetUserOnline_r.user_online)
  return user_online_.Add();
}
void GetUserOnline_r::add_user_online(const ::std::string& value) {
  user_online_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:p2p.GetUserOnline_r.user_online)
}
#if LANG_CXX11
void GetUserOnline_r::add_user_online(::std::string&& value) {
  user_online_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:p2p.GetUserOnline_r.user_online)
}
#endif
void GetUserOnline_r::add_user_online(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  user_online_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:p2p.GetUserOnline_r.user_online)
}
void GetUserOnline_r::add_user_online(const char* value, size_t size) {
  user_online_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:p2p.GetUserOnline_r.user_online)
}
const ::google::protobuf::RepeatedPtrField< ::std::string>&
GetUserOnline_r::user_online() const {
  // @@protoc_insertion_point(field_list:p2p.GetUserOnline_r.user_online)
  return user_online_;
}
::google::protobuf::RepeatedPtrField< ::std::string>*
GetUserOnline_r::mutable_user_online() {
  // @@protoc_insertion_point(field_mutable_list:p2p.GetUserOnline_r.user_online)
  return &user_online_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Info::kPeerFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Info::Info()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_peer_2dto_2dpeer_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:p2p.Info)
}
Info::Info(const Info& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  peer_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_peer()) {
    peer_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.peer_);
  }
  // @@protoc_insertion_point(copy_constructor:p2p.Info)
}

void Info::SharedCtor() {
  _cached_size_ = 0;
  peer_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

Info::~Info() {
  // @@protoc_insertion_point(destructor:p2p.Info)
  SharedDtor();
}

void Info::SharedDtor() {
  peer_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void Info::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Info::descriptor() {
  protobuf_peer_2dto_2dpeer_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_peer_2dto_2dpeer_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Info& Info::default_instance() {
  protobuf_peer_2dto_2dpeer_2eproto::InitDefaults();
  return *internal_default_instance();
}

Info* Info::New(::google::protobuf::Arena* arena) const {
  Info* n = new Info;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Info::Clear() {
// @@protoc_insertion_point(message_clear_start:p2p.Info)
  if (has_peer()) {
    GOOGLE_DCHECK(!peer_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
    (*peer_.UnsafeRawStringPointer())->clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Info::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:p2p.Info)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string peer = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_peer()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->peer().data(), this->peer().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "p2p.Info.peer");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:p2p.Info)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:p2p.Info)
  return false;
#undef DO_
}

void Info::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:p2p.Info)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string peer = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->peer().data(), this->peer().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "p2p.Info.peer");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->peer(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:p2p.Info)
}

::google::protobuf::uint8* Info::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2p.Info)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string peer = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->peer().data(), this->peer().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "p2p.Info.peer");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->peer(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2p.Info)
  return target;
}

size_t Info::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2p.Info)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // required string peer = 1;
  if (has_peer()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->peer());
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Info::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:p2p.Info)
  GOOGLE_DCHECK_NE(&from, this);
  const Info* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Info>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:p2p.Info)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:p2p.Info)
    MergeFrom(*source);
  }
}

void Info::MergeFrom(const Info& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:p2p.Info)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_peer()) {
    set_has_peer();
    peer_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.peer_);
  }
}

void Info::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:p2p.Info)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Info::CopyFrom(const Info& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2p.Info)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Info::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void Info::Swap(Info* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Info::InternalSwap(Info* other) {
  peer_.Swap(&other->peer_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Info::GetMetadata() const {
  protobuf_peer_2dto_2dpeer_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_peer_2dto_2dpeer_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Info

// required string peer = 1;
bool Info::has_peer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Info::set_has_peer() {
  _has_bits_[0] |= 0x00000001u;
}
void Info::clear_has_peer() {
  _has_bits_[0] &= ~0x00000001u;
}
void Info::clear_peer() {
  peer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_peer();
}
const ::std::string& Info::peer() const {
  // @@protoc_insertion_point(field_get:p2p.Info.peer)
  return peer_.GetNoArena();
}
void Info::set_peer(const ::std::string& value) {
  set_has_peer();
  peer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:p2p.Info.peer)
}
#if LANG_CXX11
void Info::set_peer(::std::string&& value) {
  set_has_peer();
  peer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:p2p.Info.peer)
}
#endif
void Info::set_peer(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_peer();
  peer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:p2p.Info.peer)
}
void Info::set_peer(const char* value, size_t size) {
  set_has_peer();
  peer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:p2p.Info.peer)
}
::std::string* Info::mutable_peer() {
  set_has_peer();
  // @@protoc_insertion_point(field_mutable:p2p.Info.peer)
  return peer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* Info::release_peer() {
  // @@protoc_insertion_point(field_release:p2p.Info.peer)
  clear_has_peer();
  return peer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void Info::set_allocated_peer(::std::string* peer) {
  if (peer != NULL) {
    set_has_peer();
  } else {
    clear_has_peer();
  }
  peer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), peer);
  // @@protoc_insertion_point(field_set_allocated:p2p.Info.peer)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Info_r::kTFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Info_r::Info_r()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_peer_2dto_2dpeer_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:p2p.Info_r)
}
Info_r::Info_r(const Info_r& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  t_ = from.t_;
  // @@protoc_insertion_point(copy_constructor:p2p.Info_r)
}

void Info_r::SharedCtor() {
  _cached_size_ = 0;
  t_ = 1;
}

Info_r::~Info_r() {
  // @@protoc_insertion_point(destructor:p2p.Info_r)
  SharedDtor();
}

void Info_r::SharedDtor() {
}

void Info_r::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Info_r::descriptor() {
  protobuf_peer_2dto_2dpeer_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_peer_2dto_2dpeer_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Info_r& Info_r::default_instance() {
  protobuf_peer_2dto_2dpeer_2eproto::InitDefaults();
  return *internal_default_instance();
}

Info_r* Info_r::New(::google::protobuf::Arena* arena) const {
  Info_r* n = new Info_r;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Info_r::Clear() {
// @@protoc_insertion_point(message_clear_start:p2p.Info_r)
  t_ = 1;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Info_r::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:p2p.Info_r)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .p2p.StatusType t = 1 [default = SUCCESS];
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::p2p::StatusType_IsValid(value)) {
            set_t(static_cast< ::p2p::StatusType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:p2p.Info_r)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:p2p.Info_r)
  return false;
#undef DO_
}

void Info_r::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:p2p.Info_r)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .p2p.StatusType t = 1 [default = SUCCESS];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->t(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:p2p.Info_r)
}

::google::protobuf::uint8* Info_r::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2p.Info_r)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .p2p.StatusType t = 1 [default = SUCCESS];
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->t(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2p.Info_r)
  return target;
}

size_t Info_r::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2p.Info_r)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // required .p2p.StatusType t = 1 [default = SUCCESS];
  if (has_t()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->t());
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Info_r::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:p2p.Info_r)
  GOOGLE_DCHECK_NE(&from, this);
  const Info_r* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Info_r>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:p2p.Info_r)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:p2p.Info_r)
    MergeFrom(*source);
  }
}

void Info_r::MergeFrom(const Info_r& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:p2p.Info_r)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_t()) {
    set_t(from.t());
  }
}

void Info_r::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:p2p.Info_r)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Info_r::CopyFrom(const Info_r& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2p.Info_r)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Info_r::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void Info_r::Swap(Info_r* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Info_r::InternalSwap(Info_r* other) {
  std::swap(t_, other->t_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Info_r::GetMetadata() const {
  protobuf_peer_2dto_2dpeer_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_peer_2dto_2dpeer_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Info_r

// required .p2p.StatusType t = 1 [default = SUCCESS];
bool Info_r::has_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Info_r::set_has_t() {
  _has_bits_[0] |= 0x00000001u;
}
void Info_r::clear_has_t() {
  _has_bits_[0] &= ~0x00000001u;
}
void Info_r::clear_t() {
  t_ = 1;
  clear_has_t();
}
::p2p::StatusType Info_r::t() const {
  // @@protoc_insertion_point(field_get:p2p.Info_r.t)
  return static_cast< ::p2p::StatusType >(t_);
}
void Info_r::set_t(::p2p::StatusType value) {
  assert(::p2p::StatusType_IsValid(value));
  set_has_t();
  t_ = value;
  // @@protoc_insertion_point(field_set:p2p.Info_r.t)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Hello_r::kTFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Hello_r::Hello_r()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_peer_2dto_2dpeer_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:p2p.Hello_r)
}
Hello_r::Hello_r(const Hello_r& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  t_ = from.t_;
  // @@protoc_insertion_point(copy_constructor:p2p.Hello_r)
}

void Hello_r::SharedCtor() {
  _cached_size_ = 0;
  t_ = 1;
}

Hello_r::~Hello_r() {
  // @@protoc_insertion_point(destructor:p2p.Hello_r)
  SharedDtor();
}

void Hello_r::SharedDtor() {
}

void Hello_r::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Hello_r::descriptor() {
  protobuf_peer_2dto_2dpeer_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_peer_2dto_2dpeer_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Hello_r& Hello_r::default_instance() {
  protobuf_peer_2dto_2dpeer_2eproto::InitDefaults();
  return *internal_default_instance();
}

Hello_r* Hello_r::New(::google::protobuf::Arena* arena) const {
  Hello_r* n = new Hello_r;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Hello_r::Clear() {
// @@protoc_insertion_point(message_clear_start:p2p.Hello_r)
  t_ = 1;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Hello_r::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:p2p.Hello_r)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .p2p.StatusType t = 1 [default = SUCCESS];
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::p2p::StatusType_IsValid(value)) {
            set_t(static_cast< ::p2p::StatusType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:p2p.Hello_r)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:p2p.Hello_r)
  return false;
#undef DO_
}

void Hello_r::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:p2p.Hello_r)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .p2p.StatusType t = 1 [default = SUCCESS];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->t(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:p2p.Hello_r)
}

::google::protobuf::uint8* Hello_r::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2p.Hello_r)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .p2p.StatusType t = 1 [default = SUCCESS];
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->t(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2p.Hello_r)
  return target;
}

size_t Hello_r::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2p.Hello_r)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // required .p2p.StatusType t = 1 [default = SUCCESS];
  if (has_t()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->t());
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Hello_r::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:p2p.Hello_r)
  GOOGLE_DCHECK_NE(&from, this);
  const Hello_r* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Hello_r>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:p2p.Hello_r)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:p2p.Hello_r)
    MergeFrom(*source);
  }
}

void Hello_r::MergeFrom(const Hello_r& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:p2p.Hello_r)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_t()) {
    set_t(from.t());
  }
}

void Hello_r::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:p2p.Hello_r)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Hello_r::CopyFrom(const Hello_r& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2p.Hello_r)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Hello_r::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void Hello_r::Swap(Hello_r* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Hello_r::InternalSwap(Hello_r* other) {
  std::swap(t_, other->t_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Hello_r::GetMetadata() const {
  protobuf_peer_2dto_2dpeer_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_peer_2dto_2dpeer_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Hello_r

// required .p2p.StatusType t = 1 [default = SUCCESS];
bool Hello_r::has_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Hello_r::set_has_t() {
  _has_bits_[0] |= 0x00000001u;
}
void Hello_r::clear_has_t() {
  _has_bits_[0] &= ~0x00000001u;
}
void Hello_r::clear_t() {
  t_ = 1;
  clear_has_t();
}
::p2p::StatusType Hello_r::t() const {
  // @@protoc_insertion_point(field_get:p2p.Hello_r.t)
  return static_cast< ::p2p::StatusType >(t_);
}
void Hello_r::set_t(::p2p::StatusType value) {
  assert(::p2p::StatusType_IsValid(value));
  set_has_t();
  t_ = value;
  // @@protoc_insertion_point(field_set:p2p.Hello_r.t)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

::google::protobuf::internal::ExplicitlyConstructed< ::std::string> Packet::_default_version_;
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Packet::kApiIdFieldNumber;
const int Packet::kUserIdFieldNumber;
const int Packet::kCntFieldNumber;
const int Packet::kInfFieldNumber;
const int Packet::kVersionFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Packet::Packet()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_peer_2dto_2dpeer_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:p2p.Packet)
}
Packet::Packet(const Packet& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  user_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_user_id()) {
    user_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.user_id_);
  }
  version_.UnsafeSetDefault(&Packet::_default_version_.get());
  if (from.has_version()) {
    version_.AssignWithDefault(&Packet::_default_version_.get(), from.version_);
  }
  if (from.has_cnt()) {
    cnt_ = new ::p2p::Connect(*from.cnt_);
  } else {
    cnt_ = NULL;
  }
  if (from.has_inf()) {
    inf_ = new ::p2p::Info(*from.inf_);
  } else {
    inf_ = NULL;
  }
  api_id_ = from.api_id_;
  // @@protoc_insertion_point(copy_constructor:p2p.Packet)
}

void Packet::SharedCtor() {
  _cached_size_ = 0;
  user_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  version_.UnsafeSetDefault(&Packet::_default_version_.get());
  ::memset(&cnt_, 0, reinterpret_cast<char*>(&inf_) -
    reinterpret_cast<char*>(&cnt_) + sizeof(inf_));
  api_id_ = 1;
}

Packet::~Packet() {
  // @@protoc_insertion_point(destructor:p2p.Packet)
  SharedDtor();
}

void Packet::SharedDtor() {
  user_id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  version_.DestroyNoArena(&Packet::_default_version_.get());
  if (this != internal_default_instance()) {
    delete cnt_;
  }
  if (this != internal_default_instance()) {
    delete inf_;
  }
}

void Packet::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Packet::descriptor() {
  protobuf_peer_2dto_2dpeer_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_peer_2dto_2dpeer_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Packet& Packet::default_instance() {
  protobuf_peer_2dto_2dpeer_2eproto::InitDefaults();
  return *internal_default_instance();
}

Packet* Packet::New(::google::protobuf::Arena* arena) const {
  Packet* n = new Packet;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Packet::Clear() {
// @@protoc_insertion_point(message_clear_start:p2p.Packet)
  if (_has_bits_[0 / 32] & 31u) {
    if (has_user_id()) {
      GOOGLE_DCHECK(!user_id_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*user_id_.UnsafeRawStringPointer())->clear();
    }
    if (has_version()) {
      GOOGLE_DCHECK(!version_.IsDefault(&Packet::_default_version_.get()));
      (*version_.UnsafeRawStringPointer())->assign(*&Packet::_default_version_.get());
    }
    if (has_cnt()) {
      GOOGLE_DCHECK(cnt_ != NULL);
      cnt_->::p2p::Connect::Clear();
    }
    if (has_inf()) {
      GOOGLE_DCHECK(inf_ != NULL);
      inf_->::p2p::Info::Clear();
    }
    api_id_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Packet::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:p2p.Packet)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .p2p.API_ID api_id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::p2p::API_ID_IsValid(value)) {
            set_api_id(static_cast< ::p2p::API_ID >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required string user_id = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_user_id()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->user_id().data(), this->user_id().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "p2p.Packet.user_id");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .p2p.Connect cnt = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_cnt()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .p2p.Info inf = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_inf()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string version = 5 [default = "0.1.0"];
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_version()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->version().data(), this->version().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "p2p.Packet.version");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:p2p.Packet)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:p2p.Packet)
  return false;
#undef DO_
}

void Packet::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:p2p.Packet)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .p2p.API_ID api_id = 1;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->api_id(), output);
  }

  // required string user_id = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->user_id().data(), this->user_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "p2p.Packet.user_id");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->user_id(), output);
  }

  // optional .p2p.Connect cnt = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->cnt_, output);
  }

  // optional .p2p.Info inf = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->inf_, output);
  }

  // optional string version = 5 [default = "0.1.0"];
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "p2p.Packet.version");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->version(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:p2p.Packet)
}

::google::protobuf::uint8* Packet::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2p.Packet)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .p2p.API_ID api_id = 1;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->api_id(), target);
  }

  // required string user_id = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->user_id().data(), this->user_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "p2p.Packet.user_id");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->user_id(), target);
  }

  // optional .p2p.Connect cnt = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->cnt_, deterministic, target);
  }

  // optional .p2p.Info inf = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *this->inf_, deterministic, target);
  }

  // optional string version = 5 [default = "0.1.0"];
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "p2p.Packet.version");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->version(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2p.Packet)
  return target;
}

size_t Packet::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:p2p.Packet)
  size_t total_size = 0;

  if (has_user_id()) {
    // required string user_id = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->user_id());
  }

  if (has_api_id()) {
    // required .p2p.API_ID api_id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->api_id());
  }

  return total_size;
}
size_t Packet::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2p.Packet)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000011) ^ 0x00000011) == 0) {  // All required fields are present.
    // required string user_id = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->user_id());

    // required .p2p.API_ID api_id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->api_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_has_bits_[0 / 32] & 14u) {
    // optional string version = 5 [default = "0.1.0"];
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->version());
    }

    // optional .p2p.Connect cnt = 3;
    if (has_cnt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->cnt_);
    }

    // optional .p2p.Info inf = 4;
    if (has_inf()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->inf_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Packet::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:p2p.Packet)
  GOOGLE_DCHECK_NE(&from, this);
  const Packet* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Packet>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:p2p.Packet)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:p2p.Packet)
    MergeFrom(*source);
  }
}

void Packet::MergeFrom(const Packet& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:p2p.Packet)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 31u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_user_id();
      user_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.user_id_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_version();
      version_.AssignWithDefault(&Packet::_default_version_.get(), from.version_);
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_cnt()->::p2p::Connect::MergeFrom(from.cnt());
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_inf()->::p2p::Info::MergeFrom(from.inf());
    }
    if (cached_has_bits & 0x00000010u) {
      api_id_ = from.api_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Packet::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:p2p.Packet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Packet::CopyFrom(const Packet& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2p.Packet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Packet::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000011) != 0x00000011) return false;
  if (has_cnt()) {
    if (!this->cnt_->IsInitialized()) return false;
  }
  if (has_inf()) {
    if (!this->inf_->IsInitialized()) return false;
  }
  return true;
}

void Packet::Swap(Packet* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Packet::InternalSwap(Packet* other) {
  user_id_.Swap(&other->user_id_);
  version_.Swap(&other->version_);
  std::swap(cnt_, other->cnt_);
  std::swap(inf_, other->inf_);
  std::swap(api_id_, other->api_id_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Packet::GetMetadata() const {
  protobuf_peer_2dto_2dpeer_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_peer_2dto_2dpeer_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Packet

// required .p2p.API_ID api_id = 1;
bool Packet::has_api_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void Packet::set_has_api_id() {
  _has_bits_[0] |= 0x00000010u;
}
void Packet::clear_has_api_id() {
  _has_bits_[0] &= ~0x00000010u;
}
void Packet::clear_api_id() {
  api_id_ = 1;
  clear_has_api_id();
}
::p2p::API_ID Packet::api_id() const {
  // @@protoc_insertion_point(field_get:p2p.Packet.api_id)
  return static_cast< ::p2p::API_ID >(api_id_);
}
void Packet::set_api_id(::p2p::API_ID value) {
  assert(::p2p::API_ID_IsValid(value));
  set_has_api_id();
  api_id_ = value;
  // @@protoc_insertion_point(field_set:p2p.Packet.api_id)
}

// required string user_id = 2;
bool Packet::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Packet::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
void Packet::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void Packet::clear_user_id() {
  user_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_user_id();
}
const ::std::string& Packet::user_id() const {
  // @@protoc_insertion_point(field_get:p2p.Packet.user_id)
  return user_id_.GetNoArena();
}
void Packet::set_user_id(const ::std::string& value) {
  set_has_user_id();
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:p2p.Packet.user_id)
}
#if LANG_CXX11
void Packet::set_user_id(::std::string&& value) {
  set_has_user_id();
  user_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:p2p.Packet.user_id)
}
#endif
void Packet::set_user_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_user_id();
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:p2p.Packet.user_id)
}
void Packet::set_user_id(const char* value, size_t size) {
  set_has_user_id();
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:p2p.Packet.user_id)
}
::std::string* Packet::mutable_user_id() {
  set_has_user_id();
  // @@protoc_insertion_point(field_mutable:p2p.Packet.user_id)
  return user_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* Packet::release_user_id() {
  // @@protoc_insertion_point(field_release:p2p.Packet.user_id)
  clear_has_user_id();
  return user_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void Packet::set_allocated_user_id(::std::string* user_id) {
  if (user_id != NULL) {
    set_has_user_id();
  } else {
    clear_has_user_id();
  }
  user_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_id);
  // @@protoc_insertion_point(field_set_allocated:p2p.Packet.user_id)
}

// optional .p2p.Connect cnt = 3;
bool Packet::has_cnt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Packet::set_has_cnt() {
  _has_bits_[0] |= 0x00000004u;
}
void Packet::clear_has_cnt() {
  _has_bits_[0] &= ~0x00000004u;
}
void Packet::clear_cnt() {
  if (cnt_ != NULL) cnt_->::p2p::Connect::Clear();
  clear_has_cnt();
}
const ::p2p::Connect& Packet::cnt() const {
  // @@protoc_insertion_point(field_get:p2p.Packet.cnt)
  return cnt_ != NULL ? *cnt_
                         : *::p2p::Connect::internal_default_instance();
}
::p2p::Connect* Packet::mutable_cnt() {
  set_has_cnt();
  if (cnt_ == NULL) {
    cnt_ = new ::p2p::Connect;
  }
  // @@protoc_insertion_point(field_mutable:p2p.Packet.cnt)
  return cnt_;
}
::p2p::Connect* Packet::release_cnt() {
  // @@protoc_insertion_point(field_release:p2p.Packet.cnt)
  clear_has_cnt();
  ::p2p::Connect* temp = cnt_;
  cnt_ = NULL;
  return temp;
}
void Packet::set_allocated_cnt(::p2p::Connect* cnt) {
  delete cnt_;
  cnt_ = cnt;
  if (cnt) {
    set_has_cnt();
  } else {
    clear_has_cnt();
  }
  // @@protoc_insertion_point(field_set_allocated:p2p.Packet.cnt)
}

// optional .p2p.Info inf = 4;
bool Packet::has_inf() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Packet::set_has_inf() {
  _has_bits_[0] |= 0x00000008u;
}
void Packet::clear_has_inf() {
  _has_bits_[0] &= ~0x00000008u;
}
void Packet::clear_inf() {
  if (inf_ != NULL) inf_->::p2p::Info::Clear();
  clear_has_inf();
}
const ::p2p::Info& Packet::inf() const {
  // @@protoc_insertion_point(field_get:p2p.Packet.inf)
  return inf_ != NULL ? *inf_
                         : *::p2p::Info::internal_default_instance();
}
::p2p::Info* Packet::mutable_inf() {
  set_has_inf();
  if (inf_ == NULL) {
    inf_ = new ::p2p::Info;
  }
  // @@protoc_insertion_point(field_mutable:p2p.Packet.inf)
  return inf_;
}
::p2p::Info* Packet::release_inf() {
  // @@protoc_insertion_point(field_release:p2p.Packet.inf)
  clear_has_inf();
  ::p2p::Info* temp = inf_;
  inf_ = NULL;
  return temp;
}
void Packet::set_allocated_inf(::p2p::Info* inf) {
  delete inf_;
  inf_ = inf;
  if (inf) {
    set_has_inf();
  } else {
    clear_has_inf();
  }
  // @@protoc_insertion_point(field_set_allocated:p2p.Packet.inf)
}

// optional string version = 5 [default = "0.1.0"];
bool Packet::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Packet::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
void Packet::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
void Packet::clear_version() {
  version_.ClearToDefaultNoArena(&Packet::_default_version_.get());
  clear_has_version();
}
const ::std::string& Packet::version() const {
  // @@protoc_insertion_point(field_get:p2p.Packet.version)
  return version_.GetNoArena();
}
void Packet::set_version(const ::std::string& value) {
  set_has_version();
  version_.SetNoArena(&Packet::_default_version_.get(), value);
  // @@protoc_insertion_point(field_set:p2p.Packet.version)
}
#if LANG_CXX11
void Packet::set_version(::std::string&& value) {
  set_has_version();
  version_.SetNoArena(
    &Packet::_default_version_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:p2p.Packet.version)
}
#endif
void Packet::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_version();
  version_.SetNoArena(&Packet::_default_version_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:p2p.Packet.version)
}
void Packet::set_version(const char* value, size_t size) {
  set_has_version();
  version_.SetNoArena(&Packet::_default_version_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:p2p.Packet.version)
}
::std::string* Packet::mutable_version() {
  set_has_version();
  // @@protoc_insertion_point(field_mutable:p2p.Packet.version)
  return version_.MutableNoArena(&Packet::_default_version_.get());
}
::std::string* Packet::release_version() {
  // @@protoc_insertion_point(field_release:p2p.Packet.version)
  clear_has_version();
  return version_.ReleaseNoArena(&Packet::_default_version_.get());
}
void Packet::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    set_has_version();
  } else {
    clear_has_version();
  }
  version_.SetAllocatedNoArena(&Packet::_default_version_.get(), version);
  // @@protoc_insertion_point(field_set_allocated:p2p.Packet.version)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

::google::protobuf::internal::ExplicitlyConstructed< ::std::string> RPacket::_default_version_;
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RPacket::kApiIdFieldNumber;
const int RPacket::kCntFieldNumber;
const int RPacket::kGuonlineFieldNumber;
const int RPacket::kInFieldNumber;
const int RPacket::kHelloFieldNumber;
const int RPacket::kVersionFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RPacket::RPacket()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_peer_2dto_2dpeer_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:p2p.RPacket)
}
RPacket::RPacket(const RPacket& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  version_.UnsafeSetDefault(&RPacket::_default_version_.get());
  if (from.has_version()) {
    version_.AssignWithDefault(&RPacket::_default_version_.get(), from.version_);
  }
  if (from.has_cnt()) {
    cnt_ = new ::p2p::Connect_r(*from.cnt_);
  } else {
    cnt_ = NULL;
  }
  if (from.has_guonline()) {
    guonline_ = new ::p2p::GetUserOnline_r(*from.guonline_);
  } else {
    guonline_ = NULL;
  }
  if (from.has_in()) {
    in_ = new ::p2p::Info_r(*from.in_);
  } else {
    in_ = NULL;
  }
  if (from.has_hello()) {
    hello_ = new ::p2p::Hello_r(*from.hello_);
  } else {
    hello_ = NULL;
  }
  api_id_ = from.api_id_;
  // @@protoc_insertion_point(copy_constructor:p2p.RPacket)
}

void RPacket::SharedCtor() {
  _cached_size_ = 0;
  version_.UnsafeSetDefault(&RPacket::_default_version_.get());
  ::memset(&cnt_, 0, reinterpret_cast<char*>(&hello_) -
    reinterpret_cast<char*>(&cnt_) + sizeof(hello_));
  api_id_ = 1;
}

RPacket::~RPacket() {
  // @@protoc_insertion_point(destructor:p2p.RPacket)
  SharedDtor();
}

void RPacket::SharedDtor() {
  version_.DestroyNoArena(&RPacket::_default_version_.get());
  if (this != internal_default_instance()) {
    delete cnt_;
  }
  if (this != internal_default_instance()) {
    delete guonline_;
  }
  if (this != internal_default_instance()) {
    delete in_;
  }
  if (this != internal_default_instance()) {
    delete hello_;
  }
}

void RPacket::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RPacket::descriptor() {
  protobuf_peer_2dto_2dpeer_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_peer_2dto_2dpeer_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const RPacket& RPacket::default_instance() {
  protobuf_peer_2dto_2dpeer_2eproto::InitDefaults();
  return *internal_default_instance();
}

RPacket* RPacket::New(::google::protobuf::Arena* arena) const {
  RPacket* n = new RPacket;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RPacket::Clear() {
// @@protoc_insertion_point(message_clear_start:p2p.RPacket)
  if (_has_bits_[0 / 32] & 63u) {
    if (has_version()) {
      GOOGLE_DCHECK(!version_.IsDefault(&RPacket::_default_version_.get()));
      (*version_.UnsafeRawStringPointer())->assign(*&RPacket::_default_version_.get());
    }
    if (has_cnt()) {
      GOOGLE_DCHECK(cnt_ != NULL);
      cnt_->::p2p::Connect_r::Clear();
    }
    if (has_guonline()) {
      GOOGLE_DCHECK(guonline_ != NULL);
      guonline_->::p2p::GetUserOnline_r::Clear();
    }
    if (has_in()) {
      GOOGLE_DCHECK(in_ != NULL);
      in_->::p2p::Info_r::Clear();
    }
    if (has_hello()) {
      GOOGLE_DCHECK(hello_ != NULL);
      hello_->::p2p::Hello_r::Clear();
    }
    api_id_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool RPacket::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:p2p.RPacket)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .p2p.API_ID api_id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::p2p::API_ID_IsValid(value)) {
            set_api_id(static_cast< ::p2p::API_ID >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .p2p.Connect_r cnt = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_cnt()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .p2p.GetUserOnline_r guonline = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_guonline()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .p2p.Info_r in = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_in()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .p2p.Hello_r hello = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_hello()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string version = 6 [default = "0.1.0"];
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(50u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_version()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->version().data(), this->version().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "p2p.RPacket.version");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:p2p.RPacket)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:p2p.RPacket)
  return false;
#undef DO_
}

void RPacket::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:p2p.RPacket)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .p2p.API_ID api_id = 1;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->api_id(), output);
  }

  // optional .p2p.Connect_r cnt = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->cnt_, output);
  }

  // optional .p2p.GetUserOnline_r guonline = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->guonline_, output);
  }

  // optional .p2p.Info_r in = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->in_, output);
  }

  // optional .p2p.Hello_r hello = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *this->hello_, output);
  }

  // optional string version = 6 [default = "0.1.0"];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "p2p.RPacket.version");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->version(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:p2p.RPacket)
}

::google::protobuf::uint8* RPacket::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2p.RPacket)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .p2p.API_ID api_id = 1;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->api_id(), target);
  }

  // optional .p2p.Connect_r cnt = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->cnt_, deterministic, target);
  }

  // optional .p2p.GetUserOnline_r guonline = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->guonline_, deterministic, target);
  }

  // optional .p2p.Info_r in = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *this->in_, deterministic, target);
  }

  // optional .p2p.Hello_r hello = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        5, *this->hello_, deterministic, target);
  }

  // optional string version = 6 [default = "0.1.0"];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "p2p.RPacket.version");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->version(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2p.RPacket)
  return target;
}

size_t RPacket::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2p.RPacket)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // required .p2p.API_ID api_id = 1;
  if (has_api_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->api_id());
  }
  if (_has_bits_[0 / 32] & 31u) {
    // optional string version = 6 [default = "0.1.0"];
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->version());
    }

    // optional .p2p.Connect_r cnt = 2;
    if (has_cnt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->cnt_);
    }

    // optional .p2p.GetUserOnline_r guonline = 3;
    if (has_guonline()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->guonline_);
    }

    // optional .p2p.Info_r in = 4;
    if (has_in()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->in_);
    }

    // optional .p2p.Hello_r hello = 5;
    if (has_hello()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->hello_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RPacket::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:p2p.RPacket)
  GOOGLE_DCHECK_NE(&from, this);
  const RPacket* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const RPacket>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:p2p.RPacket)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:p2p.RPacket)
    MergeFrom(*source);
  }
}

void RPacket::MergeFrom(const RPacket& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:p2p.RPacket)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 63u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_version();
      version_.AssignWithDefault(&RPacket::_default_version_.get(), from.version_);
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_cnt()->::p2p::Connect_r::MergeFrom(from.cnt());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_guonline()->::p2p::GetUserOnline_r::MergeFrom(from.guonline());
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_in()->::p2p::Info_r::MergeFrom(from.in());
    }
    if (cached_has_bits & 0x00000010u) {
      mutable_hello()->::p2p::Hello_r::MergeFrom(from.hello());
    }
    if (cached_has_bits & 0x00000020u) {
      api_id_ = from.api_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void RPacket::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:p2p.RPacket)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RPacket::CopyFrom(const RPacket& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2p.RPacket)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RPacket::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000020) != 0x00000020) return false;
  if (has_cnt()) {
    if (!this->cnt_->IsInitialized()) return false;
  }
  if (has_in()) {
    if (!this->in_->IsInitialized()) return false;
  }
  if (has_hello()) {
    if (!this->hello_->IsInitialized()) return false;
  }
  return true;
}

void RPacket::Swap(RPacket* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RPacket::InternalSwap(RPacket* other) {
  version_.Swap(&other->version_);
  std::swap(cnt_, other->cnt_);
  std::swap(guonline_, other->guonline_);
  std::swap(in_, other->in_);
  std::swap(hello_, other->hello_);
  std::swap(api_id_, other->api_id_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata RPacket::GetMetadata() const {
  protobuf_peer_2dto_2dpeer_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_peer_2dto_2dpeer_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RPacket

// required .p2p.API_ID api_id = 1;
bool RPacket::has_api_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void RPacket::set_has_api_id() {
  _has_bits_[0] |= 0x00000020u;
}
void RPacket::clear_has_api_id() {
  _has_bits_[0] &= ~0x00000020u;
}
void RPacket::clear_api_id() {
  api_id_ = 1;
  clear_has_api_id();
}
::p2p::API_ID RPacket::api_id() const {
  // @@protoc_insertion_point(field_get:p2p.RPacket.api_id)
  return static_cast< ::p2p::API_ID >(api_id_);
}
void RPacket::set_api_id(::p2p::API_ID value) {
  assert(::p2p::API_ID_IsValid(value));
  set_has_api_id();
  api_id_ = value;
  // @@protoc_insertion_point(field_set:p2p.RPacket.api_id)
}

// optional .p2p.Connect_r cnt = 2;
bool RPacket::has_cnt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void RPacket::set_has_cnt() {
  _has_bits_[0] |= 0x00000002u;
}
void RPacket::clear_has_cnt() {
  _has_bits_[0] &= ~0x00000002u;
}
void RPacket::clear_cnt() {
  if (cnt_ != NULL) cnt_->::p2p::Connect_r::Clear();
  clear_has_cnt();
}
const ::p2p::Connect_r& RPacket::cnt() const {
  // @@protoc_insertion_point(field_get:p2p.RPacket.cnt)
  return cnt_ != NULL ? *cnt_
                         : *::p2p::Connect_r::internal_default_instance();
}
::p2p::Connect_r* RPacket::mutable_cnt() {
  set_has_cnt();
  if (cnt_ == NULL) {
    cnt_ = new ::p2p::Connect_r;
  }
  // @@protoc_insertion_point(field_mutable:p2p.RPacket.cnt)
  return cnt_;
}
::p2p::Connect_r* RPacket::release_cnt() {
  // @@protoc_insertion_point(field_release:p2p.RPacket.cnt)
  clear_has_cnt();
  ::p2p::Connect_r* temp = cnt_;
  cnt_ = NULL;
  return temp;
}
void RPacket::set_allocated_cnt(::p2p::Connect_r* cnt) {
  delete cnt_;
  cnt_ = cnt;
  if (cnt) {
    set_has_cnt();
  } else {
    clear_has_cnt();
  }
  // @@protoc_insertion_point(field_set_allocated:p2p.RPacket.cnt)
}

// optional .p2p.GetUserOnline_r guonline = 3;
bool RPacket::has_guonline() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void RPacket::set_has_guonline() {
  _has_bits_[0] |= 0x00000004u;
}
void RPacket::clear_has_guonline() {
  _has_bits_[0] &= ~0x00000004u;
}
void RPacket::clear_guonline() {
  if (guonline_ != NULL) guonline_->::p2p::GetUserOnline_r::Clear();
  clear_has_guonline();
}
const ::p2p::GetUserOnline_r& RPacket::guonline() const {
  // @@protoc_insertion_point(field_get:p2p.RPacket.guonline)
  return guonline_ != NULL ? *guonline_
                         : *::p2p::GetUserOnline_r::internal_default_instance();
}
::p2p::GetUserOnline_r* RPacket::mutable_guonline() {
  set_has_guonline();
  if (guonline_ == NULL) {
    guonline_ = new ::p2p::GetUserOnline_r;
  }
  // @@protoc_insertion_point(field_mutable:p2p.RPacket.guonline)
  return guonline_;
}
::p2p::GetUserOnline_r* RPacket::release_guonline() {
  // @@protoc_insertion_point(field_release:p2p.RPacket.guonline)
  clear_has_guonline();
  ::p2p::GetUserOnline_r* temp = guonline_;
  guonline_ = NULL;
  return temp;
}
void RPacket::set_allocated_guonline(::p2p::GetUserOnline_r* guonline) {
  delete guonline_;
  guonline_ = guonline;
  if (guonline) {
    set_has_guonline();
  } else {
    clear_has_guonline();
  }
  // @@protoc_insertion_point(field_set_allocated:p2p.RPacket.guonline)
}

// optional .p2p.Info_r in = 4;
bool RPacket::has_in() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void RPacket::set_has_in() {
  _has_bits_[0] |= 0x00000008u;
}
void RPacket::clear_has_in() {
  _has_bits_[0] &= ~0x00000008u;
}
void RPacket::clear_in() {
  if (in_ != NULL) in_->::p2p::Info_r::Clear();
  clear_has_in();
}
const ::p2p::Info_r& RPacket::in() const {
  // @@protoc_insertion_point(field_get:p2p.RPacket.in)
  return in_ != NULL ? *in_
                         : *::p2p::Info_r::internal_default_instance();
}
::p2p::Info_r* RPacket::mutable_in() {
  set_has_in();
  if (in_ == NULL) {
    in_ = new ::p2p::Info_r;
  }
  // @@protoc_insertion_point(field_mutable:p2p.RPacket.in)
  return in_;
}
::p2p::Info_r* RPacket::release_in() {
  // @@protoc_insertion_point(field_release:p2p.RPacket.in)
  clear_has_in();
  ::p2p::Info_r* temp = in_;
  in_ = NULL;
  return temp;
}
void RPacket::set_allocated_in(::p2p::Info_r* in) {
  delete in_;
  in_ = in;
  if (in) {
    set_has_in();
  } else {
    clear_has_in();
  }
  // @@protoc_insertion_point(field_set_allocated:p2p.RPacket.in)
}

// optional .p2p.Hello_r hello = 5;
bool RPacket::has_hello() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void RPacket::set_has_hello() {
  _has_bits_[0] |= 0x00000010u;
}
void RPacket::clear_has_hello() {
  _has_bits_[0] &= ~0x00000010u;
}
void RPacket::clear_hello() {
  if (hello_ != NULL) hello_->::p2p::Hello_r::Clear();
  clear_has_hello();
}
const ::p2p::Hello_r& RPacket::hello() const {
  // @@protoc_insertion_point(field_get:p2p.RPacket.hello)
  return hello_ != NULL ? *hello_
                         : *::p2p::Hello_r::internal_default_instance();
}
::p2p::Hello_r* RPacket::mutable_hello() {
  set_has_hello();
  if (hello_ == NULL) {
    hello_ = new ::p2p::Hello_r;
  }
  // @@protoc_insertion_point(field_mutable:p2p.RPacket.hello)
  return hello_;
}
::p2p::Hello_r* RPacket::release_hello() {
  // @@protoc_insertion_point(field_release:p2p.RPacket.hello)
  clear_has_hello();
  ::p2p::Hello_r* temp = hello_;
  hello_ = NULL;
  return temp;
}
void RPacket::set_allocated_hello(::p2p::Hello_r* hello) {
  delete hello_;
  hello_ = hello;
  if (hello) {
    set_has_hello();
  } else {
    clear_has_hello();
  }
  // @@protoc_insertion_point(field_set_allocated:p2p.RPacket.hello)
}

// optional string version = 6 [default = "0.1.0"];
bool RPacket::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void RPacket::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
void RPacket::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
void RPacket::clear_version() {
  version_.ClearToDefaultNoArena(&RPacket::_default_version_.get());
  clear_has_version();
}
const ::std::string& RPacket::version() const {
  // @@protoc_insertion_point(field_get:p2p.RPacket.version)
  return version_.GetNoArena();
}
void RPacket::set_version(const ::std::string& value) {
  set_has_version();
  version_.SetNoArena(&RPacket::_default_version_.get(), value);
  // @@protoc_insertion_point(field_set:p2p.RPacket.version)
}
#if LANG_CXX11
void RPacket::set_version(::std::string&& value) {
  set_has_version();
  version_.SetNoArena(
    &RPacket::_default_version_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:p2p.RPacket.version)
}
#endif
void RPacket::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_version();
  version_.SetNoArena(&RPacket::_default_version_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:p2p.RPacket.version)
}
void RPacket::set_version(const char* value, size_t size) {
  set_has_version();
  version_.SetNoArena(&RPacket::_default_version_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:p2p.RPacket.version)
}
::std::string* RPacket::mutable_version() {
  set_has_version();
  // @@protoc_insertion_point(field_mutable:p2p.RPacket.version)
  return version_.MutableNoArena(&RPacket::_default_version_.get());
}
::std::string* RPacket::release_version() {
  // @@protoc_insertion_point(field_release:p2p.RPacket.version)
  clear_has_version();
  return version_.ReleaseNoArena(&RPacket::_default_version_.get());
}
void RPacket::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    set_has_version();
  } else {
    clear_has_version();
  }
  version_.SetAllocatedNoArena(&RPacket::_default_version_.get(), version);
  // @@protoc_insertion_point(field_set_allocated:p2p.RPacket.version)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Address::kIdFieldNumber;
const int Address::kAddrFieldNumber;
const int Address::kPortFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Address::Address()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_peer_2dto_2dpeer_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:p2p.Address)
}
Address::Address(const Address& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  addr_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_addr()) {
    addr_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.addr_);
  }
  id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_id()) {
    id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.id_);
  }
  port_ = from.port_;
  // @@protoc_insertion_point(copy_constructor:p2p.Address)
}

void Address::SharedCtor() {
  _cached_size_ = 0;
  addr_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  port_ = 0;
}

Address::~Address() {
  // @@protoc_insertion_point(destructor:p2p.Address)
  SharedDtor();
}

void Address::SharedDtor() {
  addr_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void Address::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Address::descriptor() {
  protobuf_peer_2dto_2dpeer_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_peer_2dto_2dpeer_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Address& Address::default_instance() {
  protobuf_peer_2dto_2dpeer_2eproto::InitDefaults();
  return *internal_default_instance();
}

Address* Address::New(::google::protobuf::Arena* arena) const {
  Address* n = new Address;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Address::Clear() {
// @@protoc_insertion_point(message_clear_start:p2p.Address)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_addr()) {
      GOOGLE_DCHECK(!addr_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*addr_.UnsafeRawStringPointer())->clear();
    }
    if (has_id()) {
      GOOGLE_DCHECK(!id_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*id_.UnsafeRawStringPointer())->clear();
    }
  }
  port_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Address::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:p2p.Address)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string addr = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_addr()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->addr().data(), this->addr().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "p2p.Address.addr");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 port = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u)) {
          set_has_port();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &port_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required string id = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_id()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->id().data(), this->id().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "p2p.Address.id");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:p2p.Address)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:p2p.Address)
  return false;
#undef DO_
}

void Address::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:p2p.Address)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string addr = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->addr().data(), this->addr().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "p2p.Address.addr");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->addr(), output);
  }

  // required int32 port = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->port(), output);
  }

  // required string id = 4;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->id().data(), this->id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "p2p.Address.id");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->id(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:p2p.Address)
}

::google::protobuf::uint8* Address::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2p.Address)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string addr = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->addr().data(), this->addr().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "p2p.Address.addr");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->addr(), target);
  }

  // required int32 port = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->port(), target);
  }

  // required string id = 4;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->id().data(), this->id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "p2p.Address.id");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->id(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2p.Address)
  return target;
}

size_t Address::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:p2p.Address)
  size_t total_size = 0;

  if (has_addr()) {
    // required string addr = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->addr());
  }

  if (has_id()) {
    // required string id = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->id());
  }

  if (has_port()) {
    // required int32 port = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->port());
  }

  return total_size;
}
size_t Address::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2p.Address)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string addr = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->addr());

    // required string id = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->id());

    // required int32 port = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->port());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Address::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:p2p.Address)
  GOOGLE_DCHECK_NE(&from, this);
  const Address* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Address>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:p2p.Address)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:p2p.Address)
    MergeFrom(*source);
  }
}

void Address::MergeFrom(const Address& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:p2p.Address)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_addr();
      addr_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.addr_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_id();
      id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.id_);
    }
    if (cached_has_bits & 0x00000004u) {
      port_ = from.port_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Address::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:p2p.Address)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Address::CopyFrom(const Address& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2p.Address)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Address::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  return true;
}

void Address::Swap(Address* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Address::InternalSwap(Address* other) {
  addr_.Swap(&other->addr_);
  id_.Swap(&other->id_);
  std::swap(port_, other->port_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Address::GetMetadata() const {
  protobuf_peer_2dto_2dpeer_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_peer_2dto_2dpeer_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Address

// required string id = 4;
bool Address::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Address::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
void Address::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
void Address::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
const ::std::string& Address::id() const {
  // @@protoc_insertion_point(field_get:p2p.Address.id)
  return id_.GetNoArena();
}
void Address::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:p2p.Address.id)
}
#if LANG_CXX11
void Address::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:p2p.Address.id)
}
#endif
void Address::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:p2p.Address.id)
}
void Address::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:p2p.Address.id)
}
::std::string* Address::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:p2p.Address.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* Address::release_id() {
  // @@protoc_insertion_point(field_release:p2p.Address.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void Address::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:p2p.Address.id)
}

// required string addr = 2;
bool Address::has_addr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Address::set_has_addr() {
  _has_bits_[0] |= 0x00000001u;
}
void Address::clear_has_addr() {
  _has_bits_[0] &= ~0x00000001u;
}
void Address::clear_addr() {
  addr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_addr();
}
const ::std::string& Address::addr() const {
  // @@protoc_insertion_point(field_get:p2p.Address.addr)
  return addr_.GetNoArena();
}
void Address::set_addr(const ::std::string& value) {
  set_has_addr();
  addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:p2p.Address.addr)
}
#if LANG_CXX11
void Address::set_addr(::std::string&& value) {
  set_has_addr();
  addr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:p2p.Address.addr)
}
#endif
void Address::set_addr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_addr();
  addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:p2p.Address.addr)
}
void Address::set_addr(const char* value, size_t size) {
  set_has_addr();
  addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:p2p.Address.addr)
}
::std::string* Address::mutable_addr() {
  set_has_addr();
  // @@protoc_insertion_point(field_mutable:p2p.Address.addr)
  return addr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* Address::release_addr() {
  // @@protoc_insertion_point(field_release:p2p.Address.addr)
  clear_has_addr();
  return addr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void Address::set_allocated_addr(::std::string* addr) {
  if (addr != NULL) {
    set_has_addr();
  } else {
    clear_has_addr();
  }
  addr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), addr);
  // @@protoc_insertion_point(field_set_allocated:p2p.Address.addr)
}

// required int32 port = 3;
bool Address::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Address::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
void Address::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
void Address::clear_port() {
  port_ = 0;
  clear_has_port();
}
::google::protobuf::int32 Address::port() const {
  // @@protoc_insertion_point(field_get:p2p.Address.port)
  return port_;
}
void Address::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:p2p.Address.port)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

::google::protobuf::internal::ExplicitlyConstructed< ::std::string> Initiative::_default_version_;
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Initiative::kTFieldNumber;
const int Initiative::kAdrFieldNumber;
const int Initiative::kVersionFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Initiative::Initiative()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_peer_2dto_2dpeer_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:p2p.Initiative)
}
Initiative::Initiative(const Initiative& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  version_.UnsafeSetDefault(&Initiative::_default_version_.get());
  if (from.has_version()) {
    version_.AssignWithDefault(&Initiative::_default_version_.get(), from.version_);
  }
  if (from.has_adr()) {
    adr_ = new ::p2p::Address(*from.adr_);
  } else {
    adr_ = NULL;
  }
  t_ = from.t_;
  // @@protoc_insertion_point(copy_constructor:p2p.Initiative)
}

void Initiative::SharedCtor() {
  _cached_size_ = 0;
  version_.UnsafeSetDefault(&Initiative::_default_version_.get());
  adr_ = NULL;
  t_ = 1;
}

Initiative::~Initiative() {
  // @@protoc_insertion_point(destructor:p2p.Initiative)
  SharedDtor();
}

void Initiative::SharedDtor() {
  version_.DestroyNoArena(&Initiative::_default_version_.get());
  if (this != internal_default_instance()) {
    delete adr_;
  }
}

void Initiative::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Initiative::descriptor() {
  protobuf_peer_2dto_2dpeer_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_peer_2dto_2dpeer_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Initiative& Initiative::default_instance() {
  protobuf_peer_2dto_2dpeer_2eproto::InitDefaults();
  return *internal_default_instance();
}

Initiative* Initiative::New(::google::protobuf::Arena* arena) const {
  Initiative* n = new Initiative;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Initiative::Clear() {
// @@protoc_insertion_point(message_clear_start:p2p.Initiative)
  if (_has_bits_[0 / 32] & 7u) {
    if (has_version()) {
      GOOGLE_DCHECK(!version_.IsDefault(&Initiative::_default_version_.get()));
      (*version_.UnsafeRawStringPointer())->assign(*&Initiative::_default_version_.get());
    }
    if (has_adr()) {
      GOOGLE_DCHECK(adr_ != NULL);
      adr_->::p2p::Address::Clear();
    }
    t_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Initiative::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:p2p.Initiative)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .p2p.InitiativeType t = 1 [default = ADDRESS];
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::p2p::InitiativeType_IsValid(value)) {
            set_t(static_cast< ::p2p::InitiativeType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .p2p.Address adr = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_adr()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string version = 3 [default = "0.1.0"];
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_version()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->version().data(), this->version().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "p2p.Initiative.version");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:p2p.Initiative)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:p2p.Initiative)
  return false;
#undef DO_
}

void Initiative::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:p2p.Initiative)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .p2p.InitiativeType t = 1 [default = ADDRESS];
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->t(), output);
  }

  // optional .p2p.Address adr = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->adr_, output);
  }

  // optional string version = 3 [default = "0.1.0"];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "p2p.Initiative.version");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->version(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:p2p.Initiative)
}

::google::protobuf::uint8* Initiative::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2p.Initiative)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .p2p.InitiativeType t = 1 [default = ADDRESS];
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->t(), target);
  }

  // optional .p2p.Address adr = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->adr_, deterministic, target);
  }

  // optional string version = 3 [default = "0.1.0"];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "p2p.Initiative.version");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->version(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2p.Initiative)
  return target;
}

size_t Initiative::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2p.Initiative)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // required .p2p.InitiativeType t = 1 [default = ADDRESS];
  if (has_t()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->t());
  }
  if (_has_bits_[0 / 32] & 3u) {
    // optional string version = 3 [default = "0.1.0"];
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->version());
    }

    // optional .p2p.Address adr = 2;
    if (has_adr()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->adr_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Initiative::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:p2p.Initiative)
  GOOGLE_DCHECK_NE(&from, this);
  const Initiative* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Initiative>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:p2p.Initiative)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:p2p.Initiative)
    MergeFrom(*source);
  }
}

void Initiative::MergeFrom(const Initiative& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:p2p.Initiative)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_version();
      version_.AssignWithDefault(&Initiative::_default_version_.get(), from.version_);
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_adr()->::p2p::Address::MergeFrom(from.adr());
    }
    if (cached_has_bits & 0x00000004u) {
      t_ = from.t_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Initiative::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:p2p.Initiative)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Initiative::CopyFrom(const Initiative& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2p.Initiative)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Initiative::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000004) != 0x00000004) return false;
  if (has_adr()) {
    if (!this->adr_->IsInitialized()) return false;
  }
  return true;
}

void Initiative::Swap(Initiative* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Initiative::InternalSwap(Initiative* other) {
  version_.Swap(&other->version_);
  std::swap(adr_, other->adr_);
  std::swap(t_, other->t_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Initiative::GetMetadata() const {
  protobuf_peer_2dto_2dpeer_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_peer_2dto_2dpeer_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Initiative

// required .p2p.InitiativeType t = 1 [default = ADDRESS];
bool Initiative::has_t() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Initiative::set_has_t() {
  _has_bits_[0] |= 0x00000004u;
}
void Initiative::clear_has_t() {
  _has_bits_[0] &= ~0x00000004u;
}
void Initiative::clear_t() {
  t_ = 1;
  clear_has_t();
}
::p2p::InitiativeType Initiative::t() const {
  // @@protoc_insertion_point(field_get:p2p.Initiative.t)
  return static_cast< ::p2p::InitiativeType >(t_);
}
void Initiative::set_t(::p2p::InitiativeType value) {
  assert(::p2p::InitiativeType_IsValid(value));
  set_has_t();
  t_ = value;
  // @@protoc_insertion_point(field_set:p2p.Initiative.t)
}

// optional .p2p.Address adr = 2;
bool Initiative::has_adr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Initiative::set_has_adr() {
  _has_bits_[0] |= 0x00000002u;
}
void Initiative::clear_has_adr() {
  _has_bits_[0] &= ~0x00000002u;
}
void Initiative::clear_adr() {
  if (adr_ != NULL) adr_->::p2p::Address::Clear();
  clear_has_adr();
}
const ::p2p::Address& Initiative::adr() const {
  // @@protoc_insertion_point(field_get:p2p.Initiative.adr)
  return adr_ != NULL ? *adr_
                         : *::p2p::Address::internal_default_instance();
}
::p2p::Address* Initiative::mutable_adr() {
  set_has_adr();
  if (adr_ == NULL) {
    adr_ = new ::p2p::Address;
  }
  // @@protoc_insertion_point(field_mutable:p2p.Initiative.adr)
  return adr_;
}
::p2p::Address* Initiative::release_adr() {
  // @@protoc_insertion_point(field_release:p2p.Initiative.adr)
  clear_has_adr();
  ::p2p::Address* temp = adr_;
  adr_ = NULL;
  return temp;
}
void Initiative::set_allocated_adr(::p2p::Address* adr) {
  delete adr_;
  adr_ = adr;
  if (adr) {
    set_has_adr();
  } else {
    clear_has_adr();
  }
  // @@protoc_insertion_point(field_set_allocated:p2p.Initiative.adr)
}

// optional string version = 3 [default = "0.1.0"];
bool Initiative::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Initiative::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
void Initiative::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
void Initiative::clear_version() {
  version_.ClearToDefaultNoArena(&Initiative::_default_version_.get());
  clear_has_version();
}
const ::std::string& Initiative::version() const {
  // @@protoc_insertion_point(field_get:p2p.Initiative.version)
  return version_.GetNoArena();
}
void Initiative::set_version(const ::std::string& value) {
  set_has_version();
  version_.SetNoArena(&Initiative::_default_version_.get(), value);
  // @@protoc_insertion_point(field_set:p2p.Initiative.version)
}
#if LANG_CXX11
void Initiative::set_version(::std::string&& value) {
  set_has_version();
  version_.SetNoArena(
    &Initiative::_default_version_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:p2p.Initiative.version)
}
#endif
void Initiative::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_version();
  version_.SetNoArena(&Initiative::_default_version_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:p2p.Initiative.version)
}
void Initiative::set_version(const char* value, size_t size) {
  set_has_version();
  version_.SetNoArena(&Initiative::_default_version_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:p2p.Initiative.version)
}
::std::string* Initiative::mutable_version() {
  set_has_version();
  // @@protoc_insertion_point(field_mutable:p2p.Initiative.version)
  return version_.MutableNoArena(&Initiative::_default_version_.get());
}
::std::string* Initiative::release_version() {
  // @@protoc_insertion_point(field_release:p2p.Initiative.version)
  clear_has_version();
  return version_.ReleaseNoArena(&Initiative::_default_version_.get());
}
void Initiative::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    set_has_version();
  } else {
    clear_has_version();
  }
  version_.SetAllocatedNoArena(&Initiative::_default_version_.get(), version);
  // @@protoc_insertion_point(field_set_allocated:p2p.Initiative.version)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace p2p

// @@protoc_insertion_point(global_scope)
