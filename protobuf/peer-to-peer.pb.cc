// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: peer-to-peer.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "peer-to-peer.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace p2p {
class ConnectRequestDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ConnectRequest> {
} _ConnectRequest_default_instance_;
class ConnectRespondDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ConnectRespond> {
} _ConnectRespond_default_instance_;
class GetUsersOnlineRespondDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<GetUsersOnlineRespond> {
} _GetUsersOnlineRespond_default_instance_;
class NotifyRequestDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<NotifyRequest> {
} _NotifyRequest_default_instance_;
class NotifyRespondDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<NotifyRespond> {
} _NotifyRespond_default_instance_;
class HelloRespondDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<HelloRespond> {
} _HelloRespond_default_instance_;
class PacketRequstDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<PacketRequst> {
} _PacketRequst_default_instance_;
class PacketRespondDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<PacketRespond> {
} _PacketRespond_default_instance_;
class AddressDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Address> {
} _Address_default_instance_;
class MessageDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Message> {
} _Message_default_instance_;

namespace protobuf_peer_2dto_2dpeer_2eproto {


namespace {

::google::protobuf::Metadata file_level_metadata[10];
const ::google::protobuf::EnumDescriptor* file_level_enum_descriptors[3];

}  // namespace

PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::ParseTableField
    const TableStruct::entries[] = {
  {0, 0, 0, ::google::protobuf::internal::kInvalidMask, 0, 0},
};

PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::AuxillaryParseTableField
    const TableStruct::aux[] = {
  ::google::protobuf::internal::AuxillaryParseTableField(),
};
PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::ParseTable const
    TableStruct::schema[] = {
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
};

const ::google::protobuf::uint32 TableStruct::offsets[] = {
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConnectRequest, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConnectRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConnectRequest, peeridentity_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConnectRequest, counter_),
  0,
  1,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConnectRespond, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConnectRespond, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConnectRespond, statustype_),
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetUsersOnlineRespond, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetUsersOnlineRespond, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetUsersOnlineRespond, usersonline_),
  ~0u,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NotifyRequest, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NotifyRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NotifyRequest, peeridentity_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NotifyRequest, payload_),
  0,
  1,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NotifyRespond, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NotifyRespond, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NotifyRespond, statustype_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NotifyRespond, payload_),
  1,
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HelloRespond, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HelloRespond, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HelloRespond, statustype_),
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PacketRequst, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PacketRequst, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PacketRequst, rpcapi_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PacketRequst, peeridentity_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PacketRequst, connectrequest_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PacketRequst, notifyrequest_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PacketRequst, version_),
  4,
  0,
  2,
  3,
  1,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PacketRespond, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PacketRespond, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PacketRespond, rpcapi_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PacketRespond, connectrespond_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PacketRespond, getusersonlinerespond_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PacketRespond, notifyrespond_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PacketRespond, hellorespond_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PacketRespond, version_),
  5,
  1,
  2,
  3,
  4,
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Address, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Address, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Address, id_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Address, address_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Address, port_),
  1,
  0,
  2,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Message, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Message, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Message, t_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Message, address_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Message, version_),
  2,
  1,
  0,
};

static const ::google::protobuf::internal::MigrationSchema schemas[] = {
  { 0, 7, sizeof(ConnectRequest)},
  { 9, 15, sizeof(ConnectRespond)},
  { 16, 22, sizeof(GetUsersOnlineRespond)},
  { 23, 30, sizeof(NotifyRequest)},
  { 32, 39, sizeof(NotifyRespond)},
  { 41, 47, sizeof(HelloRespond)},
  { 48, 58, sizeof(PacketRequst)},
  { 63, 74, sizeof(PacketRespond)},
  { 80, 88, sizeof(Address)},
  { 91, 99, sizeof(Message)},
};

static ::google::protobuf::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::google::protobuf::Message*>(&_ConnectRequest_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_ConnectRespond_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_GetUsersOnlineRespond_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_NotifyRequest_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_NotifyRespond_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_HelloRespond_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_PacketRequst_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_PacketRespond_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_Address_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_Message_default_instance_),
};

namespace {

void protobuf_AssignDescriptors() {
  AddDescriptors();
  ::google::protobuf::MessageFactory* factory = NULL;
  AssignDescriptors(
      "peer-to-peer.proto", schemas, file_default_instances, TableStruct::offsets, factory,
      file_level_metadata, file_level_enum_descriptors, NULL);
}

void protobuf_AssignDescriptorsOnce() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &protobuf_AssignDescriptors);
}

void protobuf_RegisterTypes(const ::std::string&) GOOGLE_ATTRIBUTE_COLD;
void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::internal::RegisterAllTypes(file_level_metadata, 10);
}

}  // namespace

void TableStruct::Shutdown() {
  _ConnectRequest_default_instance_.Shutdown();
  delete file_level_metadata[0].reflection;
  _ConnectRespond_default_instance_.Shutdown();
  delete file_level_metadata[1].reflection;
  _GetUsersOnlineRespond_default_instance_.Shutdown();
  delete file_level_metadata[2].reflection;
  _NotifyRequest_default_instance_.Shutdown();
  delete file_level_metadata[3].reflection;
  _NotifyRespond_default_instance_.Shutdown();
  delete file_level_metadata[4].reflection;
  _HelloRespond_default_instance_.Shutdown();
  delete file_level_metadata[5].reflection;
  _PacketRequst_default_instance_.Shutdown();
  delete file_level_metadata[6].reflection;
  PacketRequst::_default_version_.Shutdown();
  _PacketRespond_default_instance_.Shutdown();
  delete file_level_metadata[7].reflection;
  PacketRespond::_default_version_.Shutdown();
  _Address_default_instance_.Shutdown();
  delete file_level_metadata[8].reflection;
  _Message_default_instance_.Shutdown();
  delete file_level_metadata[9].reflection;
  Message::_default_version_.Shutdown();
}

void TableStruct::InitDefaultsImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::internal::InitProtobufDefaults();
  _ConnectRequest_default_instance_.DefaultConstruct();
  _ConnectRespond_default_instance_.DefaultConstruct();
  _GetUsersOnlineRespond_default_instance_.DefaultConstruct();
  _NotifyRequest_default_instance_.DefaultConstruct();
  _NotifyRespond_default_instance_.DefaultConstruct();
  _HelloRespond_default_instance_.DefaultConstruct();
  PacketRequst::_default_version_.DefaultConstruct();
  *PacketRequst::_default_version_.get_mutable() = ::std::string("0.1.0", 5);
  _PacketRequst_default_instance_.DefaultConstruct();
  PacketRespond::_default_version_.DefaultConstruct();
  *PacketRespond::_default_version_.get_mutable() = ::std::string("0.1.0", 5);
  _PacketRespond_default_instance_.DefaultConstruct();
  _Address_default_instance_.DefaultConstruct();
  Message::_default_version_.DefaultConstruct();
  *Message::_default_version_.get_mutable() = ::std::string("0.1.0", 5);
  _Message_default_instance_.DefaultConstruct();
  _PacketRequst_default_instance_.get_mutable()->connectrequest_ = const_cast< ::p2p::ConnectRequest*>(
      ::p2p::ConnectRequest::internal_default_instance());
  _PacketRequst_default_instance_.get_mutable()->notifyrequest_ = const_cast< ::p2p::NotifyRequest*>(
      ::p2p::NotifyRequest::internal_default_instance());
  _PacketRespond_default_instance_.get_mutable()->connectrespond_ = const_cast< ::p2p::ConnectRespond*>(
      ::p2p::ConnectRespond::internal_default_instance());
  _PacketRespond_default_instance_.get_mutable()->getusersonlinerespond_ = const_cast< ::p2p::GetUsersOnlineRespond*>(
      ::p2p::GetUsersOnlineRespond::internal_default_instance());
  _PacketRespond_default_instance_.get_mutable()->notifyrespond_ = const_cast< ::p2p::NotifyRespond*>(
      ::p2p::NotifyRespond::internal_default_instance());
  _PacketRespond_default_instance_.get_mutable()->hellorespond_ = const_cast< ::p2p::HelloRespond*>(
      ::p2p::HelloRespond::internal_default_instance());
  _Message_default_instance_.get_mutable()->address_ = const_cast< ::p2p::Address*>(
      ::p2p::Address::internal_default_instance());
}

void InitDefaults() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &TableStruct::InitDefaultsImpl);
}
void AddDescriptorsImpl() {
  InitDefaults();
  static const char descriptor[] = {
      "\n\022peer-to-peer.proto\022\003p2p\"7\n\016ConnectRequ"
      "est\022\024\n\014peerIdentity\030\001 \002(\t\022\017\n\007counter\030\002 \002"
      "(\005\">\n\016ConnectRespond\022,\n\nstatusType\030\001 \002(\016"
      "2\017.p2p.StatusType:\007SUCCESS\",\n\025GetUsersOn"
      "lineRespond\022\023\n\013usersOnline\030\001 \003(\t\"6\n\rNoti"
      "fyRequest\022\024\n\014peerIdentity\030\001 \002(\t\022\017\n\007paylo"
      "ad\030\002 \001(\014\"N\n\rNotifyRespond\022,\n\nstatusType\030"
      "\001 \002(\0162\017.p2p.StatusType:\007SUCCESS\022\017\n\007paylo"
      "ad\030\002 \001(\014\"<\n\014HelloRespond\022,\n\nstatusType\030\001"
      " \002(\0162\017.p2p.StatusType:\007SUCCESS\"\261\001\n\014Packe"
      "tRequst\022\033\n\006rpcApi\030\001 \002(\0162\013.p2p.RPCAPI\022\024\n\014"
      "peerIdentity\030\002 \002(\t\022+\n\016connectRequest\030\003 \001"
      "(\0132\023.p2p.ConnectRequest\022)\n\rnotifyRequest"
      "\030\004 \001(\0132\022.p2p.NotifyRequest\022\026\n\007version\030\005 "
      "\001(\t:\0050.1.0\"\200\002\n\rPacketRespond\022\033\n\006rpcApi\030\001"
      " \002(\0162\013.p2p.RPCAPI\022+\n\016connectRespond\030\002 \001("
      "\0132\023.p2p.ConnectRespond\0229\n\025getUsersOnline"
      "Respond\030\003 \001(\0132\032.p2p.GetUsersOnlineRespon"
      "d\022)\n\rnotifyRespond\030\004 \001(\0132\022.p2p.NotifyRes"
      "pond\022\'\n\014helloRespond\030\005 \001(\0132\021.p2p.HelloRe"
      "spond\022\026\n\007version\030\006 \001(\t:\0050.1.0\"4\n\007Address"
      "\022\n\n\002id\030\004 \002(\t\022\017\n\007address\030\002 \002(\t\022\014\n\004port\030\003 "
      "\002(\005\"f\n\007Message\022$\n\001t\030\001 \002(\0162\020.p2p.MessageT"
      "ype:\007ADDRESS\022\035\n\007address\030\002 \001(\0132\014.p2p.Addr"
      "ess\022\026\n\007version\030\003 \001(\t:\0050.1.0*V\n\006RPCAPI\022\022\n"
      "\016GETUSERSONLINE\020\001\022\013\n\007CONNECT\020\002\022\010\n\004INFO\020\003"
      "\022\013\n\007OFFLINE\020\004\022\t\n\005HEART\020\005\022\t\n\005HELLO\020\006*a\n\nS"
      "tatusType\022\013\n\007SUCCESS\020\001\022\013\n\007FAILURE\020\002\022\t\n\005R"
      "EADY\020\003\022\t\n\005CLOSE\020\004\022\013\n\007RUNNING\020\005\022\013\n\007NOEXIS"
      "T\020\006\022\t\n\005EXIST\020\007*\032\n\013MessageType\022\013\n\007ADDRESS"
      "\020\001"
  };
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
      descriptor, 1202);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "peer-to-peer.proto", &protobuf_RegisterTypes);
  ::google::protobuf::internal::OnShutdown(&TableStruct::Shutdown);
}

void AddDescriptors() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &AddDescriptorsImpl);
}
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer {
  StaticDescriptorInitializer() {
    AddDescriptors();
  }
} static_descriptor_initializer;

}  // namespace protobuf_peer_2dto_2dpeer_2eproto

const ::google::protobuf::EnumDescriptor* RPCAPI_descriptor() {
  protobuf_peer_2dto_2dpeer_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_peer_2dto_2dpeer_2eproto::file_level_enum_descriptors[0];
}
bool RPCAPI_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* StatusType_descriptor() {
  protobuf_peer_2dto_2dpeer_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_peer_2dto_2dpeer_2eproto::file_level_enum_descriptors[1];
}
bool StatusType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* MessageType_descriptor() {
  protobuf_peer_2dto_2dpeer_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_peer_2dto_2dpeer_2eproto::file_level_enum_descriptors[2];
}
bool MessageType_IsValid(int value) {
  switch (value) {
    case 1:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ConnectRequest::kPeerIdentityFieldNumber;
const int ConnectRequest::kCounterFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ConnectRequest::ConnectRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_peer_2dto_2dpeer_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:p2p.ConnectRequest)
}
ConnectRequest::ConnectRequest(const ConnectRequest& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  peeridentity_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_peeridentity()) {
    peeridentity_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.peeridentity_);
  }
  counter_ = from.counter_;
  // @@protoc_insertion_point(copy_constructor:p2p.ConnectRequest)
}

void ConnectRequest::SharedCtor() {
  _cached_size_ = 0;
  peeridentity_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  counter_ = 0;
}

ConnectRequest::~ConnectRequest() {
  // @@protoc_insertion_point(destructor:p2p.ConnectRequest)
  SharedDtor();
}

void ConnectRequest::SharedDtor() {
  peeridentity_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void ConnectRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ConnectRequest::descriptor() {
  protobuf_peer_2dto_2dpeer_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_peer_2dto_2dpeer_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const ConnectRequest& ConnectRequest::default_instance() {
  protobuf_peer_2dto_2dpeer_2eproto::InitDefaults();
  return *internal_default_instance();
}

ConnectRequest* ConnectRequest::New(::google::protobuf::Arena* arena) const {
  ConnectRequest* n = new ConnectRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ConnectRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:p2p.ConnectRequest)
  if (has_peeridentity()) {
    GOOGLE_DCHECK(!peeridentity_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
    (*peeridentity_.UnsafeRawStringPointer())->clear();
  }
  counter_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ConnectRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:p2p.ConnectRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string peerIdentity = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_peeridentity()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->peeridentity().data(), this->peeridentity().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "p2p.ConnectRequest.peerIdentity");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 counter = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u)) {
          set_has_counter();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &counter_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:p2p.ConnectRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:p2p.ConnectRequest)
  return false;
#undef DO_
}

void ConnectRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:p2p.ConnectRequest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string peerIdentity = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->peeridentity().data(), this->peeridentity().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "p2p.ConnectRequest.peerIdentity");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->peeridentity(), output);
  }

  // required int32 counter = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->counter(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:p2p.ConnectRequest)
}

::google::protobuf::uint8* ConnectRequest::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2p.ConnectRequest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string peerIdentity = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->peeridentity().data(), this->peeridentity().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "p2p.ConnectRequest.peerIdentity");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->peeridentity(), target);
  }

  // required int32 counter = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->counter(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2p.ConnectRequest)
  return target;
}

size_t ConnectRequest::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:p2p.ConnectRequest)
  size_t total_size = 0;

  if (has_peeridentity()) {
    // required string peerIdentity = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->peeridentity());
  }

  if (has_counter()) {
    // required int32 counter = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->counter());
  }

  return total_size;
}
size_t ConnectRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2p.ConnectRequest)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string peerIdentity = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->peeridentity());

    // required int32 counter = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->counter());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ConnectRequest::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:p2p.ConnectRequest)
  GOOGLE_DCHECK_NE(&from, this);
  const ConnectRequest* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const ConnectRequest>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:p2p.ConnectRequest)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:p2p.ConnectRequest)
    MergeFrom(*source);
  }
}

void ConnectRequest::MergeFrom(const ConnectRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:p2p.ConnectRequest)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_peeridentity();
      peeridentity_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.peeridentity_);
    }
    if (cached_has_bits & 0x00000002u) {
      counter_ = from.counter_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ConnectRequest::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:p2p.ConnectRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ConnectRequest::CopyFrom(const ConnectRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2p.ConnectRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConnectRequest::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  return true;
}

void ConnectRequest::Swap(ConnectRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ConnectRequest::InternalSwap(ConnectRequest* other) {
  peeridentity_.Swap(&other->peeridentity_);
  std::swap(counter_, other->counter_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ConnectRequest::GetMetadata() const {
  protobuf_peer_2dto_2dpeer_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_peer_2dto_2dpeer_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ConnectRequest

// required string peerIdentity = 1;
bool ConnectRequest::has_peeridentity() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ConnectRequest::set_has_peeridentity() {
  _has_bits_[0] |= 0x00000001u;
}
void ConnectRequest::clear_has_peeridentity() {
  _has_bits_[0] &= ~0x00000001u;
}
void ConnectRequest::clear_peeridentity() {
  peeridentity_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_peeridentity();
}
const ::std::string& ConnectRequest::peeridentity() const {
  // @@protoc_insertion_point(field_get:p2p.ConnectRequest.peerIdentity)
  return peeridentity_.GetNoArena();
}
void ConnectRequest::set_peeridentity(const ::std::string& value) {
  set_has_peeridentity();
  peeridentity_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:p2p.ConnectRequest.peerIdentity)
}
#if LANG_CXX11
void ConnectRequest::set_peeridentity(::std::string&& value) {
  set_has_peeridentity();
  peeridentity_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:p2p.ConnectRequest.peerIdentity)
}
#endif
void ConnectRequest::set_peeridentity(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_peeridentity();
  peeridentity_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:p2p.ConnectRequest.peerIdentity)
}
void ConnectRequest::set_peeridentity(const char* value, size_t size) {
  set_has_peeridentity();
  peeridentity_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:p2p.ConnectRequest.peerIdentity)
}
::std::string* ConnectRequest::mutable_peeridentity() {
  set_has_peeridentity();
  // @@protoc_insertion_point(field_mutable:p2p.ConnectRequest.peerIdentity)
  return peeridentity_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* ConnectRequest::release_peeridentity() {
  // @@protoc_insertion_point(field_release:p2p.ConnectRequest.peerIdentity)
  clear_has_peeridentity();
  return peeridentity_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ConnectRequest::set_allocated_peeridentity(::std::string* peeridentity) {
  if (peeridentity != NULL) {
    set_has_peeridentity();
  } else {
    clear_has_peeridentity();
  }
  peeridentity_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), peeridentity);
  // @@protoc_insertion_point(field_set_allocated:p2p.ConnectRequest.peerIdentity)
}

// required int32 counter = 2;
bool ConnectRequest::has_counter() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ConnectRequest::set_has_counter() {
  _has_bits_[0] |= 0x00000002u;
}
void ConnectRequest::clear_has_counter() {
  _has_bits_[0] &= ~0x00000002u;
}
void ConnectRequest::clear_counter() {
  counter_ = 0;
  clear_has_counter();
}
::google::protobuf::int32 ConnectRequest::counter() const {
  // @@protoc_insertion_point(field_get:p2p.ConnectRequest.counter)
  return counter_;
}
void ConnectRequest::set_counter(::google::protobuf::int32 value) {
  set_has_counter();
  counter_ = value;
  // @@protoc_insertion_point(field_set:p2p.ConnectRequest.counter)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ConnectRespond::kStatusTypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ConnectRespond::ConnectRespond()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_peer_2dto_2dpeer_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:p2p.ConnectRespond)
}
ConnectRespond::ConnectRespond(const ConnectRespond& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  statustype_ = from.statustype_;
  // @@protoc_insertion_point(copy_constructor:p2p.ConnectRespond)
}

void ConnectRespond::SharedCtor() {
  _cached_size_ = 0;
  statustype_ = 1;
}

ConnectRespond::~ConnectRespond() {
  // @@protoc_insertion_point(destructor:p2p.ConnectRespond)
  SharedDtor();
}

void ConnectRespond::SharedDtor() {
}

void ConnectRespond::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ConnectRespond::descriptor() {
  protobuf_peer_2dto_2dpeer_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_peer_2dto_2dpeer_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const ConnectRespond& ConnectRespond::default_instance() {
  protobuf_peer_2dto_2dpeer_2eproto::InitDefaults();
  return *internal_default_instance();
}

ConnectRespond* ConnectRespond::New(::google::protobuf::Arena* arena) const {
  ConnectRespond* n = new ConnectRespond;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ConnectRespond::Clear() {
// @@protoc_insertion_point(message_clear_start:p2p.ConnectRespond)
  statustype_ = 1;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ConnectRespond::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:p2p.ConnectRespond)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .p2p.StatusType statusType = 1 [default = SUCCESS];
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::p2p::StatusType_IsValid(value)) {
            set_statustype(static_cast< ::p2p::StatusType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:p2p.ConnectRespond)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:p2p.ConnectRespond)
  return false;
#undef DO_
}

void ConnectRespond::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:p2p.ConnectRespond)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .p2p.StatusType statusType = 1 [default = SUCCESS];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->statustype(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:p2p.ConnectRespond)
}

::google::protobuf::uint8* ConnectRespond::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2p.ConnectRespond)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .p2p.StatusType statusType = 1 [default = SUCCESS];
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->statustype(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2p.ConnectRespond)
  return target;
}

size_t ConnectRespond::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2p.ConnectRespond)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // required .p2p.StatusType statusType = 1 [default = SUCCESS];
  if (has_statustype()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->statustype());
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ConnectRespond::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:p2p.ConnectRespond)
  GOOGLE_DCHECK_NE(&from, this);
  const ConnectRespond* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const ConnectRespond>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:p2p.ConnectRespond)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:p2p.ConnectRespond)
    MergeFrom(*source);
  }
}

void ConnectRespond::MergeFrom(const ConnectRespond& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:p2p.ConnectRespond)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_statustype()) {
    set_statustype(from.statustype());
  }
}

void ConnectRespond::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:p2p.ConnectRespond)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ConnectRespond::CopyFrom(const ConnectRespond& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2p.ConnectRespond)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConnectRespond::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void ConnectRespond::Swap(ConnectRespond* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ConnectRespond::InternalSwap(ConnectRespond* other) {
  std::swap(statustype_, other->statustype_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ConnectRespond::GetMetadata() const {
  protobuf_peer_2dto_2dpeer_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_peer_2dto_2dpeer_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ConnectRespond

// required .p2p.StatusType statusType = 1 [default = SUCCESS];
bool ConnectRespond::has_statustype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ConnectRespond::set_has_statustype() {
  _has_bits_[0] |= 0x00000001u;
}
void ConnectRespond::clear_has_statustype() {
  _has_bits_[0] &= ~0x00000001u;
}
void ConnectRespond::clear_statustype() {
  statustype_ = 1;
  clear_has_statustype();
}
::p2p::StatusType ConnectRespond::statustype() const {
  // @@protoc_insertion_point(field_get:p2p.ConnectRespond.statusType)
  return static_cast< ::p2p::StatusType >(statustype_);
}
void ConnectRespond::set_statustype(::p2p::StatusType value) {
  assert(::p2p::StatusType_IsValid(value));
  set_has_statustype();
  statustype_ = value;
  // @@protoc_insertion_point(field_set:p2p.ConnectRespond.statusType)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GetUsersOnlineRespond::kUsersOnlineFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GetUsersOnlineRespond::GetUsersOnlineRespond()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_peer_2dto_2dpeer_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:p2p.GetUsersOnlineRespond)
}
GetUsersOnlineRespond::GetUsersOnlineRespond(const GetUsersOnlineRespond& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      usersonline_(from.usersonline_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:p2p.GetUsersOnlineRespond)
}

void GetUsersOnlineRespond::SharedCtor() {
  _cached_size_ = 0;
}

GetUsersOnlineRespond::~GetUsersOnlineRespond() {
  // @@protoc_insertion_point(destructor:p2p.GetUsersOnlineRespond)
  SharedDtor();
}

void GetUsersOnlineRespond::SharedDtor() {
}

void GetUsersOnlineRespond::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GetUsersOnlineRespond::descriptor() {
  protobuf_peer_2dto_2dpeer_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_peer_2dto_2dpeer_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const GetUsersOnlineRespond& GetUsersOnlineRespond::default_instance() {
  protobuf_peer_2dto_2dpeer_2eproto::InitDefaults();
  return *internal_default_instance();
}

GetUsersOnlineRespond* GetUsersOnlineRespond::New(::google::protobuf::Arena* arena) const {
  GetUsersOnlineRespond* n = new GetUsersOnlineRespond;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void GetUsersOnlineRespond::Clear() {
// @@protoc_insertion_point(message_clear_start:p2p.GetUsersOnlineRespond)
  usersonline_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool GetUsersOnlineRespond::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:p2p.GetUsersOnlineRespond)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated string usersOnline = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_usersonline()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->usersonline(this->usersonline_size() - 1).data(),
            this->usersonline(this->usersonline_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "p2p.GetUsersOnlineRespond.usersOnline");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:p2p.GetUsersOnlineRespond)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:p2p.GetUsersOnlineRespond)
  return false;
#undef DO_
}

void GetUsersOnlineRespond::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:p2p.GetUsersOnlineRespond)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string usersOnline = 1;
  for (int i = 0, n = this->usersonline_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->usersonline(i).data(), this->usersonline(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "p2p.GetUsersOnlineRespond.usersOnline");
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->usersonline(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:p2p.GetUsersOnlineRespond)
}

::google::protobuf::uint8* GetUsersOnlineRespond::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2p.GetUsersOnlineRespond)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string usersOnline = 1;
  for (int i = 0, n = this->usersonline_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->usersonline(i).data(), this->usersonline(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "p2p.GetUsersOnlineRespond.usersOnline");
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(1, this->usersonline(i), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2p.GetUsersOnlineRespond)
  return target;
}

size_t GetUsersOnlineRespond::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2p.GetUsersOnlineRespond)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // repeated string usersOnline = 1;
  total_size += 1 *
      ::google::protobuf::internal::FromIntSize(this->usersonline_size());
  for (int i = 0, n = this->usersonline_size(); i < n; i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->usersonline(i));
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetUsersOnlineRespond::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:p2p.GetUsersOnlineRespond)
  GOOGLE_DCHECK_NE(&from, this);
  const GetUsersOnlineRespond* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const GetUsersOnlineRespond>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:p2p.GetUsersOnlineRespond)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:p2p.GetUsersOnlineRespond)
    MergeFrom(*source);
  }
}

void GetUsersOnlineRespond::MergeFrom(const GetUsersOnlineRespond& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:p2p.GetUsersOnlineRespond)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  usersonline_.MergeFrom(from.usersonline_);
}

void GetUsersOnlineRespond::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:p2p.GetUsersOnlineRespond)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetUsersOnlineRespond::CopyFrom(const GetUsersOnlineRespond& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2p.GetUsersOnlineRespond)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetUsersOnlineRespond::IsInitialized() const {
  return true;
}

void GetUsersOnlineRespond::Swap(GetUsersOnlineRespond* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GetUsersOnlineRespond::InternalSwap(GetUsersOnlineRespond* other) {
  usersonline_.InternalSwap(&other->usersonline_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata GetUsersOnlineRespond::GetMetadata() const {
  protobuf_peer_2dto_2dpeer_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_peer_2dto_2dpeer_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// GetUsersOnlineRespond

// repeated string usersOnline = 1;
int GetUsersOnlineRespond::usersonline_size() const {
  return usersonline_.size();
}
void GetUsersOnlineRespond::clear_usersonline() {
  usersonline_.Clear();
}
const ::std::string& GetUsersOnlineRespond::usersonline(int index) const {
  // @@protoc_insertion_point(field_get:p2p.GetUsersOnlineRespond.usersOnline)
  return usersonline_.Get(index);
}
::std::string* GetUsersOnlineRespond::mutable_usersonline(int index) {
  // @@protoc_insertion_point(field_mutable:p2p.GetUsersOnlineRespond.usersOnline)
  return usersonline_.Mutable(index);
}
void GetUsersOnlineRespond::set_usersonline(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:p2p.GetUsersOnlineRespond.usersOnline)
  usersonline_.Mutable(index)->assign(value);
}
#if LANG_CXX11
void GetUsersOnlineRespond::set_usersonline(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:p2p.GetUsersOnlineRespond.usersOnline)
  usersonline_.Mutable(index)->assign(std::move(value));
}
#endif
void GetUsersOnlineRespond::set_usersonline(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  usersonline_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:p2p.GetUsersOnlineRespond.usersOnline)
}
void GetUsersOnlineRespond::set_usersonline(int index, const char* value, size_t size) {
  usersonline_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:p2p.GetUsersOnlineRespond.usersOnline)
}
::std::string* GetUsersOnlineRespond::add_usersonline() {
  // @@protoc_insertion_point(field_add_mutable:p2p.GetUsersOnlineRespond.usersOnline)
  return usersonline_.Add();
}
void GetUsersOnlineRespond::add_usersonline(const ::std::string& value) {
  usersonline_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:p2p.GetUsersOnlineRespond.usersOnline)
}
#if LANG_CXX11
void GetUsersOnlineRespond::add_usersonline(::std::string&& value) {
  usersonline_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:p2p.GetUsersOnlineRespond.usersOnline)
}
#endif
void GetUsersOnlineRespond::add_usersonline(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  usersonline_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:p2p.GetUsersOnlineRespond.usersOnline)
}
void GetUsersOnlineRespond::add_usersonline(const char* value, size_t size) {
  usersonline_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:p2p.GetUsersOnlineRespond.usersOnline)
}
const ::google::protobuf::RepeatedPtrField< ::std::string>&
GetUsersOnlineRespond::usersonline() const {
  // @@protoc_insertion_point(field_list:p2p.GetUsersOnlineRespond.usersOnline)
  return usersonline_;
}
::google::protobuf::RepeatedPtrField< ::std::string>*
GetUsersOnlineRespond::mutable_usersonline() {
  // @@protoc_insertion_point(field_mutable_list:p2p.GetUsersOnlineRespond.usersOnline)
  return &usersonline_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int NotifyRequest::kPeerIdentityFieldNumber;
const int NotifyRequest::kPayloadFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

NotifyRequest::NotifyRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_peer_2dto_2dpeer_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:p2p.NotifyRequest)
}
NotifyRequest::NotifyRequest(const NotifyRequest& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  peeridentity_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_peeridentity()) {
    peeridentity_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.peeridentity_);
  }
  payload_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_payload()) {
    payload_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.payload_);
  }
  // @@protoc_insertion_point(copy_constructor:p2p.NotifyRequest)
}

void NotifyRequest::SharedCtor() {
  _cached_size_ = 0;
  peeridentity_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  payload_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

NotifyRequest::~NotifyRequest() {
  // @@protoc_insertion_point(destructor:p2p.NotifyRequest)
  SharedDtor();
}

void NotifyRequest::SharedDtor() {
  peeridentity_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  payload_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void NotifyRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NotifyRequest::descriptor() {
  protobuf_peer_2dto_2dpeer_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_peer_2dto_2dpeer_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const NotifyRequest& NotifyRequest::default_instance() {
  protobuf_peer_2dto_2dpeer_2eproto::InitDefaults();
  return *internal_default_instance();
}

NotifyRequest* NotifyRequest::New(::google::protobuf::Arena* arena) const {
  NotifyRequest* n = new NotifyRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void NotifyRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:p2p.NotifyRequest)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_peeridentity()) {
      GOOGLE_DCHECK(!peeridentity_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*peeridentity_.UnsafeRawStringPointer())->clear();
    }
    if (has_payload()) {
      GOOGLE_DCHECK(!payload_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*payload_.UnsafeRawStringPointer())->clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool NotifyRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:p2p.NotifyRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string peerIdentity = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_peeridentity()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->peeridentity().data(), this->peeridentity().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "p2p.NotifyRequest.peerIdentity");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes payload = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_payload()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:p2p.NotifyRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:p2p.NotifyRequest)
  return false;
#undef DO_
}

void NotifyRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:p2p.NotifyRequest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string peerIdentity = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->peeridentity().data(), this->peeridentity().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "p2p.NotifyRequest.peerIdentity");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->peeridentity(), output);
  }

  // optional bytes payload = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->payload(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:p2p.NotifyRequest)
}

::google::protobuf::uint8* NotifyRequest::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2p.NotifyRequest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string peerIdentity = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->peeridentity().data(), this->peeridentity().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "p2p.NotifyRequest.peerIdentity");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->peeridentity(), target);
  }

  // optional bytes payload = 2;
  if (cached_has_bits & 0x00000002u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->payload(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2p.NotifyRequest)
  return target;
}

size_t NotifyRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2p.NotifyRequest)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // required string peerIdentity = 1;
  if (has_peeridentity()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->peeridentity());
  }
  // optional bytes payload = 2;
  if (has_payload()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->payload());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NotifyRequest::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:p2p.NotifyRequest)
  GOOGLE_DCHECK_NE(&from, this);
  const NotifyRequest* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const NotifyRequest>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:p2p.NotifyRequest)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:p2p.NotifyRequest)
    MergeFrom(*source);
  }
}

void NotifyRequest::MergeFrom(const NotifyRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:p2p.NotifyRequest)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_peeridentity();
      peeridentity_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.peeridentity_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_payload();
      payload_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.payload_);
    }
  }
}

void NotifyRequest::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:p2p.NotifyRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NotifyRequest::CopyFrom(const NotifyRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2p.NotifyRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotifyRequest::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void NotifyRequest::Swap(NotifyRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void NotifyRequest::InternalSwap(NotifyRequest* other) {
  peeridentity_.Swap(&other->peeridentity_);
  payload_.Swap(&other->payload_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata NotifyRequest::GetMetadata() const {
  protobuf_peer_2dto_2dpeer_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_peer_2dto_2dpeer_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// NotifyRequest

// required string peerIdentity = 1;
bool NotifyRequest::has_peeridentity() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void NotifyRequest::set_has_peeridentity() {
  _has_bits_[0] |= 0x00000001u;
}
void NotifyRequest::clear_has_peeridentity() {
  _has_bits_[0] &= ~0x00000001u;
}
void NotifyRequest::clear_peeridentity() {
  peeridentity_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_peeridentity();
}
const ::std::string& NotifyRequest::peeridentity() const {
  // @@protoc_insertion_point(field_get:p2p.NotifyRequest.peerIdentity)
  return peeridentity_.GetNoArena();
}
void NotifyRequest::set_peeridentity(const ::std::string& value) {
  set_has_peeridentity();
  peeridentity_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:p2p.NotifyRequest.peerIdentity)
}
#if LANG_CXX11
void NotifyRequest::set_peeridentity(::std::string&& value) {
  set_has_peeridentity();
  peeridentity_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:p2p.NotifyRequest.peerIdentity)
}
#endif
void NotifyRequest::set_peeridentity(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_peeridentity();
  peeridentity_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:p2p.NotifyRequest.peerIdentity)
}
void NotifyRequest::set_peeridentity(const char* value, size_t size) {
  set_has_peeridentity();
  peeridentity_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:p2p.NotifyRequest.peerIdentity)
}
::std::string* NotifyRequest::mutable_peeridentity() {
  set_has_peeridentity();
  // @@protoc_insertion_point(field_mutable:p2p.NotifyRequest.peerIdentity)
  return peeridentity_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* NotifyRequest::release_peeridentity() {
  // @@protoc_insertion_point(field_release:p2p.NotifyRequest.peerIdentity)
  clear_has_peeridentity();
  return peeridentity_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void NotifyRequest::set_allocated_peeridentity(::std::string* peeridentity) {
  if (peeridentity != NULL) {
    set_has_peeridentity();
  } else {
    clear_has_peeridentity();
  }
  peeridentity_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), peeridentity);
  // @@protoc_insertion_point(field_set_allocated:p2p.NotifyRequest.peerIdentity)
}

// optional bytes payload = 2;
bool NotifyRequest::has_payload() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void NotifyRequest::set_has_payload() {
  _has_bits_[0] |= 0x00000002u;
}
void NotifyRequest::clear_has_payload() {
  _has_bits_[0] &= ~0x00000002u;
}
void NotifyRequest::clear_payload() {
  payload_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_payload();
}
const ::std::string& NotifyRequest::payload() const {
  // @@protoc_insertion_point(field_get:p2p.NotifyRequest.payload)
  return payload_.GetNoArena();
}
void NotifyRequest::set_payload(const ::std::string& value) {
  set_has_payload();
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:p2p.NotifyRequest.payload)
}
#if LANG_CXX11
void NotifyRequest::set_payload(::std::string&& value) {
  set_has_payload();
  payload_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:p2p.NotifyRequest.payload)
}
#endif
void NotifyRequest::set_payload(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_payload();
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:p2p.NotifyRequest.payload)
}
void NotifyRequest::set_payload(const void* value, size_t size) {
  set_has_payload();
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:p2p.NotifyRequest.payload)
}
::std::string* NotifyRequest::mutable_payload() {
  set_has_payload();
  // @@protoc_insertion_point(field_mutable:p2p.NotifyRequest.payload)
  return payload_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* NotifyRequest::release_payload() {
  // @@protoc_insertion_point(field_release:p2p.NotifyRequest.payload)
  clear_has_payload();
  return payload_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void NotifyRequest::set_allocated_payload(::std::string* payload) {
  if (payload != NULL) {
    set_has_payload();
  } else {
    clear_has_payload();
  }
  payload_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), payload);
  // @@protoc_insertion_point(field_set_allocated:p2p.NotifyRequest.payload)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int NotifyRespond::kStatusTypeFieldNumber;
const int NotifyRespond::kPayloadFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

NotifyRespond::NotifyRespond()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_peer_2dto_2dpeer_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:p2p.NotifyRespond)
}
NotifyRespond::NotifyRespond(const NotifyRespond& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  payload_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_payload()) {
    payload_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.payload_);
  }
  statustype_ = from.statustype_;
  // @@protoc_insertion_point(copy_constructor:p2p.NotifyRespond)
}

void NotifyRespond::SharedCtor() {
  _cached_size_ = 0;
  payload_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  statustype_ = 1;
}

NotifyRespond::~NotifyRespond() {
  // @@protoc_insertion_point(destructor:p2p.NotifyRespond)
  SharedDtor();
}

void NotifyRespond::SharedDtor() {
  payload_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void NotifyRespond::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NotifyRespond::descriptor() {
  protobuf_peer_2dto_2dpeer_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_peer_2dto_2dpeer_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const NotifyRespond& NotifyRespond::default_instance() {
  protobuf_peer_2dto_2dpeer_2eproto::InitDefaults();
  return *internal_default_instance();
}

NotifyRespond* NotifyRespond::New(::google::protobuf::Arena* arena) const {
  NotifyRespond* n = new NotifyRespond;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void NotifyRespond::Clear() {
// @@protoc_insertion_point(message_clear_start:p2p.NotifyRespond)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_payload()) {
      GOOGLE_DCHECK(!payload_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*payload_.UnsafeRawStringPointer())->clear();
    }
    statustype_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool NotifyRespond::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:p2p.NotifyRespond)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .p2p.StatusType statusType = 1 [default = SUCCESS];
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::p2p::StatusType_IsValid(value)) {
            set_statustype(static_cast< ::p2p::StatusType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes payload = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_payload()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:p2p.NotifyRespond)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:p2p.NotifyRespond)
  return false;
#undef DO_
}

void NotifyRespond::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:p2p.NotifyRespond)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .p2p.StatusType statusType = 1 [default = SUCCESS];
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->statustype(), output);
  }

  // optional bytes payload = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->payload(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:p2p.NotifyRespond)
}

::google::protobuf::uint8* NotifyRespond::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2p.NotifyRespond)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .p2p.StatusType statusType = 1 [default = SUCCESS];
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->statustype(), target);
  }

  // optional bytes payload = 2;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->payload(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2p.NotifyRespond)
  return target;
}

size_t NotifyRespond::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2p.NotifyRespond)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // required .p2p.StatusType statusType = 1 [default = SUCCESS];
  if (has_statustype()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->statustype());
  }
  // optional bytes payload = 2;
  if (has_payload()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->payload());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NotifyRespond::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:p2p.NotifyRespond)
  GOOGLE_DCHECK_NE(&from, this);
  const NotifyRespond* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const NotifyRespond>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:p2p.NotifyRespond)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:p2p.NotifyRespond)
    MergeFrom(*source);
  }
}

void NotifyRespond::MergeFrom(const NotifyRespond& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:p2p.NotifyRespond)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_payload();
      payload_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.payload_);
    }
    if (cached_has_bits & 0x00000002u) {
      statustype_ = from.statustype_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void NotifyRespond::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:p2p.NotifyRespond)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NotifyRespond::CopyFrom(const NotifyRespond& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2p.NotifyRespond)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotifyRespond::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;
  return true;
}

void NotifyRespond::Swap(NotifyRespond* other) {
  if (other == this) return;
  InternalSwap(other);
}
void NotifyRespond::InternalSwap(NotifyRespond* other) {
  payload_.Swap(&other->payload_);
  std::swap(statustype_, other->statustype_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata NotifyRespond::GetMetadata() const {
  protobuf_peer_2dto_2dpeer_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_peer_2dto_2dpeer_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// NotifyRespond

// required .p2p.StatusType statusType = 1 [default = SUCCESS];
bool NotifyRespond::has_statustype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void NotifyRespond::set_has_statustype() {
  _has_bits_[0] |= 0x00000002u;
}
void NotifyRespond::clear_has_statustype() {
  _has_bits_[0] &= ~0x00000002u;
}
void NotifyRespond::clear_statustype() {
  statustype_ = 1;
  clear_has_statustype();
}
::p2p::StatusType NotifyRespond::statustype() const {
  // @@protoc_insertion_point(field_get:p2p.NotifyRespond.statusType)
  return static_cast< ::p2p::StatusType >(statustype_);
}
void NotifyRespond::set_statustype(::p2p::StatusType value) {
  assert(::p2p::StatusType_IsValid(value));
  set_has_statustype();
  statustype_ = value;
  // @@protoc_insertion_point(field_set:p2p.NotifyRespond.statusType)
}

// optional bytes payload = 2;
bool NotifyRespond::has_payload() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void NotifyRespond::set_has_payload() {
  _has_bits_[0] |= 0x00000001u;
}
void NotifyRespond::clear_has_payload() {
  _has_bits_[0] &= ~0x00000001u;
}
void NotifyRespond::clear_payload() {
  payload_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_payload();
}
const ::std::string& NotifyRespond::payload() const {
  // @@protoc_insertion_point(field_get:p2p.NotifyRespond.payload)
  return payload_.GetNoArena();
}
void NotifyRespond::set_payload(const ::std::string& value) {
  set_has_payload();
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:p2p.NotifyRespond.payload)
}
#if LANG_CXX11
void NotifyRespond::set_payload(::std::string&& value) {
  set_has_payload();
  payload_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:p2p.NotifyRespond.payload)
}
#endif
void NotifyRespond::set_payload(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_payload();
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:p2p.NotifyRespond.payload)
}
void NotifyRespond::set_payload(const void* value, size_t size) {
  set_has_payload();
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:p2p.NotifyRespond.payload)
}
::std::string* NotifyRespond::mutable_payload() {
  set_has_payload();
  // @@protoc_insertion_point(field_mutable:p2p.NotifyRespond.payload)
  return payload_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* NotifyRespond::release_payload() {
  // @@protoc_insertion_point(field_release:p2p.NotifyRespond.payload)
  clear_has_payload();
  return payload_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void NotifyRespond::set_allocated_payload(::std::string* payload) {
  if (payload != NULL) {
    set_has_payload();
  } else {
    clear_has_payload();
  }
  payload_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), payload);
  // @@protoc_insertion_point(field_set_allocated:p2p.NotifyRespond.payload)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int HelloRespond::kStatusTypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

HelloRespond::HelloRespond()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_peer_2dto_2dpeer_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:p2p.HelloRespond)
}
HelloRespond::HelloRespond(const HelloRespond& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  statustype_ = from.statustype_;
  // @@protoc_insertion_point(copy_constructor:p2p.HelloRespond)
}

void HelloRespond::SharedCtor() {
  _cached_size_ = 0;
  statustype_ = 1;
}

HelloRespond::~HelloRespond() {
  // @@protoc_insertion_point(destructor:p2p.HelloRespond)
  SharedDtor();
}

void HelloRespond::SharedDtor() {
}

void HelloRespond::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* HelloRespond::descriptor() {
  protobuf_peer_2dto_2dpeer_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_peer_2dto_2dpeer_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const HelloRespond& HelloRespond::default_instance() {
  protobuf_peer_2dto_2dpeer_2eproto::InitDefaults();
  return *internal_default_instance();
}

HelloRespond* HelloRespond::New(::google::protobuf::Arena* arena) const {
  HelloRespond* n = new HelloRespond;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void HelloRespond::Clear() {
// @@protoc_insertion_point(message_clear_start:p2p.HelloRespond)
  statustype_ = 1;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool HelloRespond::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:p2p.HelloRespond)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .p2p.StatusType statusType = 1 [default = SUCCESS];
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::p2p::StatusType_IsValid(value)) {
            set_statustype(static_cast< ::p2p::StatusType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:p2p.HelloRespond)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:p2p.HelloRespond)
  return false;
#undef DO_
}

void HelloRespond::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:p2p.HelloRespond)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .p2p.StatusType statusType = 1 [default = SUCCESS];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->statustype(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:p2p.HelloRespond)
}

::google::protobuf::uint8* HelloRespond::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2p.HelloRespond)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .p2p.StatusType statusType = 1 [default = SUCCESS];
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->statustype(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2p.HelloRespond)
  return target;
}

size_t HelloRespond::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2p.HelloRespond)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // required .p2p.StatusType statusType = 1 [default = SUCCESS];
  if (has_statustype()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->statustype());
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HelloRespond::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:p2p.HelloRespond)
  GOOGLE_DCHECK_NE(&from, this);
  const HelloRespond* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const HelloRespond>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:p2p.HelloRespond)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:p2p.HelloRespond)
    MergeFrom(*source);
  }
}

void HelloRespond::MergeFrom(const HelloRespond& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:p2p.HelloRespond)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_statustype()) {
    set_statustype(from.statustype());
  }
}

void HelloRespond::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:p2p.HelloRespond)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void HelloRespond::CopyFrom(const HelloRespond& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2p.HelloRespond)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HelloRespond::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void HelloRespond::Swap(HelloRespond* other) {
  if (other == this) return;
  InternalSwap(other);
}
void HelloRespond::InternalSwap(HelloRespond* other) {
  std::swap(statustype_, other->statustype_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata HelloRespond::GetMetadata() const {
  protobuf_peer_2dto_2dpeer_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_peer_2dto_2dpeer_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// HelloRespond

// required .p2p.StatusType statusType = 1 [default = SUCCESS];
bool HelloRespond::has_statustype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void HelloRespond::set_has_statustype() {
  _has_bits_[0] |= 0x00000001u;
}
void HelloRespond::clear_has_statustype() {
  _has_bits_[0] &= ~0x00000001u;
}
void HelloRespond::clear_statustype() {
  statustype_ = 1;
  clear_has_statustype();
}
::p2p::StatusType HelloRespond::statustype() const {
  // @@protoc_insertion_point(field_get:p2p.HelloRespond.statusType)
  return static_cast< ::p2p::StatusType >(statustype_);
}
void HelloRespond::set_statustype(::p2p::StatusType value) {
  assert(::p2p::StatusType_IsValid(value));
  set_has_statustype();
  statustype_ = value;
  // @@protoc_insertion_point(field_set:p2p.HelloRespond.statusType)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

::google::protobuf::internal::ExplicitlyConstructed< ::std::string> PacketRequst::_default_version_;
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PacketRequst::kRpcApiFieldNumber;
const int PacketRequst::kPeerIdentityFieldNumber;
const int PacketRequst::kConnectRequestFieldNumber;
const int PacketRequst::kNotifyRequestFieldNumber;
const int PacketRequst::kVersionFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PacketRequst::PacketRequst()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_peer_2dto_2dpeer_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:p2p.PacketRequst)
}
PacketRequst::PacketRequst(const PacketRequst& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  peeridentity_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_peeridentity()) {
    peeridentity_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.peeridentity_);
  }
  version_.UnsafeSetDefault(&PacketRequst::_default_version_.get());
  if (from.has_version()) {
    version_.AssignWithDefault(&PacketRequst::_default_version_.get(), from.version_);
  }
  if (from.has_connectrequest()) {
    connectrequest_ = new ::p2p::ConnectRequest(*from.connectrequest_);
  } else {
    connectrequest_ = NULL;
  }
  if (from.has_notifyrequest()) {
    notifyrequest_ = new ::p2p::NotifyRequest(*from.notifyrequest_);
  } else {
    notifyrequest_ = NULL;
  }
  rpcapi_ = from.rpcapi_;
  // @@protoc_insertion_point(copy_constructor:p2p.PacketRequst)
}

void PacketRequst::SharedCtor() {
  _cached_size_ = 0;
  peeridentity_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  version_.UnsafeSetDefault(&PacketRequst::_default_version_.get());
  ::memset(&connectrequest_, 0, reinterpret_cast<char*>(&notifyrequest_) -
    reinterpret_cast<char*>(&connectrequest_) + sizeof(notifyrequest_));
  rpcapi_ = 1;
}

PacketRequst::~PacketRequst() {
  // @@protoc_insertion_point(destructor:p2p.PacketRequst)
  SharedDtor();
}

void PacketRequst::SharedDtor() {
  peeridentity_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  version_.DestroyNoArena(&PacketRequst::_default_version_.get());
  if (this != internal_default_instance()) {
    delete connectrequest_;
  }
  if (this != internal_default_instance()) {
    delete notifyrequest_;
  }
}

void PacketRequst::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PacketRequst::descriptor() {
  protobuf_peer_2dto_2dpeer_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_peer_2dto_2dpeer_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const PacketRequst& PacketRequst::default_instance() {
  protobuf_peer_2dto_2dpeer_2eproto::InitDefaults();
  return *internal_default_instance();
}

PacketRequst* PacketRequst::New(::google::protobuf::Arena* arena) const {
  PacketRequst* n = new PacketRequst;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PacketRequst::Clear() {
// @@protoc_insertion_point(message_clear_start:p2p.PacketRequst)
  if (_has_bits_[0 / 32] & 31u) {
    if (has_peeridentity()) {
      GOOGLE_DCHECK(!peeridentity_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*peeridentity_.UnsafeRawStringPointer())->clear();
    }
    if (has_version()) {
      GOOGLE_DCHECK(!version_.IsDefault(&PacketRequst::_default_version_.get()));
      (*version_.UnsafeRawStringPointer())->assign(*&PacketRequst::_default_version_.get());
    }
    if (has_connectrequest()) {
      GOOGLE_DCHECK(connectrequest_ != NULL);
      connectrequest_->::p2p::ConnectRequest::Clear();
    }
    if (has_notifyrequest()) {
      GOOGLE_DCHECK(notifyrequest_ != NULL);
      notifyrequest_->::p2p::NotifyRequest::Clear();
    }
    rpcapi_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool PacketRequst::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:p2p.PacketRequst)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .p2p.RPCAPI rpcApi = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::p2p::RPCAPI_IsValid(value)) {
            set_rpcapi(static_cast< ::p2p::RPCAPI >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required string peerIdentity = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_peeridentity()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->peeridentity().data(), this->peeridentity().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "p2p.PacketRequst.peerIdentity");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .p2p.ConnectRequest connectRequest = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_connectrequest()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .p2p.NotifyRequest notifyRequest = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_notifyrequest()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string version = 5 [default = "0.1.0"];
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_version()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->version().data(), this->version().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "p2p.PacketRequst.version");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:p2p.PacketRequst)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:p2p.PacketRequst)
  return false;
#undef DO_
}

void PacketRequst::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:p2p.PacketRequst)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .p2p.RPCAPI rpcApi = 1;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->rpcapi(), output);
  }

  // required string peerIdentity = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->peeridentity().data(), this->peeridentity().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "p2p.PacketRequst.peerIdentity");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->peeridentity(), output);
  }

  // optional .p2p.ConnectRequest connectRequest = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->connectrequest_, output);
  }

  // optional .p2p.NotifyRequest notifyRequest = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->notifyrequest_, output);
  }

  // optional string version = 5 [default = "0.1.0"];
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "p2p.PacketRequst.version");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->version(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:p2p.PacketRequst)
}

::google::protobuf::uint8* PacketRequst::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2p.PacketRequst)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .p2p.RPCAPI rpcApi = 1;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->rpcapi(), target);
  }

  // required string peerIdentity = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->peeridentity().data(), this->peeridentity().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "p2p.PacketRequst.peerIdentity");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->peeridentity(), target);
  }

  // optional .p2p.ConnectRequest connectRequest = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->connectrequest_, deterministic, target);
  }

  // optional .p2p.NotifyRequest notifyRequest = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *this->notifyrequest_, deterministic, target);
  }

  // optional string version = 5 [default = "0.1.0"];
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "p2p.PacketRequst.version");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->version(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2p.PacketRequst)
  return target;
}

size_t PacketRequst::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:p2p.PacketRequst)
  size_t total_size = 0;

  if (has_peeridentity()) {
    // required string peerIdentity = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->peeridentity());
  }

  if (has_rpcapi()) {
    // required .p2p.RPCAPI rpcApi = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->rpcapi());
  }

  return total_size;
}
size_t PacketRequst::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2p.PacketRequst)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000011) ^ 0x00000011) == 0) {  // All required fields are present.
    // required string peerIdentity = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->peeridentity());

    // required .p2p.RPCAPI rpcApi = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->rpcapi());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_has_bits_[0 / 32] & 14u) {
    // optional string version = 5 [default = "0.1.0"];
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->version());
    }

    // optional .p2p.ConnectRequest connectRequest = 3;
    if (has_connectrequest()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->connectrequest_);
    }

    // optional .p2p.NotifyRequest notifyRequest = 4;
    if (has_notifyrequest()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->notifyrequest_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PacketRequst::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:p2p.PacketRequst)
  GOOGLE_DCHECK_NE(&from, this);
  const PacketRequst* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const PacketRequst>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:p2p.PacketRequst)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:p2p.PacketRequst)
    MergeFrom(*source);
  }
}

void PacketRequst::MergeFrom(const PacketRequst& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:p2p.PacketRequst)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 31u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_peeridentity();
      peeridentity_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.peeridentity_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_version();
      version_.AssignWithDefault(&PacketRequst::_default_version_.get(), from.version_);
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_connectrequest()->::p2p::ConnectRequest::MergeFrom(from.connectrequest());
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_notifyrequest()->::p2p::NotifyRequest::MergeFrom(from.notifyrequest());
    }
    if (cached_has_bits & 0x00000010u) {
      rpcapi_ = from.rpcapi_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void PacketRequst::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:p2p.PacketRequst)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PacketRequst::CopyFrom(const PacketRequst& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2p.PacketRequst)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PacketRequst::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000011) != 0x00000011) return false;
  if (has_connectrequest()) {
    if (!this->connectrequest_->IsInitialized()) return false;
  }
  if (has_notifyrequest()) {
    if (!this->notifyrequest_->IsInitialized()) return false;
  }
  return true;
}

void PacketRequst::Swap(PacketRequst* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PacketRequst::InternalSwap(PacketRequst* other) {
  peeridentity_.Swap(&other->peeridentity_);
  version_.Swap(&other->version_);
  std::swap(connectrequest_, other->connectrequest_);
  std::swap(notifyrequest_, other->notifyrequest_);
  std::swap(rpcapi_, other->rpcapi_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata PacketRequst::GetMetadata() const {
  protobuf_peer_2dto_2dpeer_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_peer_2dto_2dpeer_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// PacketRequst

// required .p2p.RPCAPI rpcApi = 1;
bool PacketRequst::has_rpcapi() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void PacketRequst::set_has_rpcapi() {
  _has_bits_[0] |= 0x00000010u;
}
void PacketRequst::clear_has_rpcapi() {
  _has_bits_[0] &= ~0x00000010u;
}
void PacketRequst::clear_rpcapi() {
  rpcapi_ = 1;
  clear_has_rpcapi();
}
::p2p::RPCAPI PacketRequst::rpcapi() const {
  // @@protoc_insertion_point(field_get:p2p.PacketRequst.rpcApi)
  return static_cast< ::p2p::RPCAPI >(rpcapi_);
}
void PacketRequst::set_rpcapi(::p2p::RPCAPI value) {
  assert(::p2p::RPCAPI_IsValid(value));
  set_has_rpcapi();
  rpcapi_ = value;
  // @@protoc_insertion_point(field_set:p2p.PacketRequst.rpcApi)
}

// required string peerIdentity = 2;
bool PacketRequst::has_peeridentity() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void PacketRequst::set_has_peeridentity() {
  _has_bits_[0] |= 0x00000001u;
}
void PacketRequst::clear_has_peeridentity() {
  _has_bits_[0] &= ~0x00000001u;
}
void PacketRequst::clear_peeridentity() {
  peeridentity_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_peeridentity();
}
const ::std::string& PacketRequst::peeridentity() const {
  // @@protoc_insertion_point(field_get:p2p.PacketRequst.peerIdentity)
  return peeridentity_.GetNoArena();
}
void PacketRequst::set_peeridentity(const ::std::string& value) {
  set_has_peeridentity();
  peeridentity_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:p2p.PacketRequst.peerIdentity)
}
#if LANG_CXX11
void PacketRequst::set_peeridentity(::std::string&& value) {
  set_has_peeridentity();
  peeridentity_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:p2p.PacketRequst.peerIdentity)
}
#endif
void PacketRequst::set_peeridentity(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_peeridentity();
  peeridentity_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:p2p.PacketRequst.peerIdentity)
}
void PacketRequst::set_peeridentity(const char* value, size_t size) {
  set_has_peeridentity();
  peeridentity_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:p2p.PacketRequst.peerIdentity)
}
::std::string* PacketRequst::mutable_peeridentity() {
  set_has_peeridentity();
  // @@protoc_insertion_point(field_mutable:p2p.PacketRequst.peerIdentity)
  return peeridentity_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* PacketRequst::release_peeridentity() {
  // @@protoc_insertion_point(field_release:p2p.PacketRequst.peerIdentity)
  clear_has_peeridentity();
  return peeridentity_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void PacketRequst::set_allocated_peeridentity(::std::string* peeridentity) {
  if (peeridentity != NULL) {
    set_has_peeridentity();
  } else {
    clear_has_peeridentity();
  }
  peeridentity_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), peeridentity);
  // @@protoc_insertion_point(field_set_allocated:p2p.PacketRequst.peerIdentity)
}

// optional .p2p.ConnectRequest connectRequest = 3;
bool PacketRequst::has_connectrequest() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void PacketRequst::set_has_connectrequest() {
  _has_bits_[0] |= 0x00000004u;
}
void PacketRequst::clear_has_connectrequest() {
  _has_bits_[0] &= ~0x00000004u;
}
void PacketRequst::clear_connectrequest() {
  if (connectrequest_ != NULL) connectrequest_->::p2p::ConnectRequest::Clear();
  clear_has_connectrequest();
}
const ::p2p::ConnectRequest& PacketRequst::connectrequest() const {
  // @@protoc_insertion_point(field_get:p2p.PacketRequst.connectRequest)
  return connectrequest_ != NULL ? *connectrequest_
                         : *::p2p::ConnectRequest::internal_default_instance();
}
::p2p::ConnectRequest* PacketRequst::mutable_connectrequest() {
  set_has_connectrequest();
  if (connectrequest_ == NULL) {
    connectrequest_ = new ::p2p::ConnectRequest;
  }
  // @@protoc_insertion_point(field_mutable:p2p.PacketRequst.connectRequest)
  return connectrequest_;
}
::p2p::ConnectRequest* PacketRequst::release_connectrequest() {
  // @@protoc_insertion_point(field_release:p2p.PacketRequst.connectRequest)
  clear_has_connectrequest();
  ::p2p::ConnectRequest* temp = connectrequest_;
  connectrequest_ = NULL;
  return temp;
}
void PacketRequst::set_allocated_connectrequest(::p2p::ConnectRequest* connectrequest) {
  delete connectrequest_;
  connectrequest_ = connectrequest;
  if (connectrequest) {
    set_has_connectrequest();
  } else {
    clear_has_connectrequest();
  }
  // @@protoc_insertion_point(field_set_allocated:p2p.PacketRequst.connectRequest)
}

// optional .p2p.NotifyRequest notifyRequest = 4;
bool PacketRequst::has_notifyrequest() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void PacketRequst::set_has_notifyrequest() {
  _has_bits_[0] |= 0x00000008u;
}
void PacketRequst::clear_has_notifyrequest() {
  _has_bits_[0] &= ~0x00000008u;
}
void PacketRequst::clear_notifyrequest() {
  if (notifyrequest_ != NULL) notifyrequest_->::p2p::NotifyRequest::Clear();
  clear_has_notifyrequest();
}
const ::p2p::NotifyRequest& PacketRequst::notifyrequest() const {
  // @@protoc_insertion_point(field_get:p2p.PacketRequst.notifyRequest)
  return notifyrequest_ != NULL ? *notifyrequest_
                         : *::p2p::NotifyRequest::internal_default_instance();
}
::p2p::NotifyRequest* PacketRequst::mutable_notifyrequest() {
  set_has_notifyrequest();
  if (notifyrequest_ == NULL) {
    notifyrequest_ = new ::p2p::NotifyRequest;
  }
  // @@protoc_insertion_point(field_mutable:p2p.PacketRequst.notifyRequest)
  return notifyrequest_;
}
::p2p::NotifyRequest* PacketRequst::release_notifyrequest() {
  // @@protoc_insertion_point(field_release:p2p.PacketRequst.notifyRequest)
  clear_has_notifyrequest();
  ::p2p::NotifyRequest* temp = notifyrequest_;
  notifyrequest_ = NULL;
  return temp;
}
void PacketRequst::set_allocated_notifyrequest(::p2p::NotifyRequest* notifyrequest) {
  delete notifyrequest_;
  notifyrequest_ = notifyrequest;
  if (notifyrequest) {
    set_has_notifyrequest();
  } else {
    clear_has_notifyrequest();
  }
  // @@protoc_insertion_point(field_set_allocated:p2p.PacketRequst.notifyRequest)
}

// optional string version = 5 [default = "0.1.0"];
bool PacketRequst::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void PacketRequst::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
void PacketRequst::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
void PacketRequst::clear_version() {
  version_.ClearToDefaultNoArena(&PacketRequst::_default_version_.get());
  clear_has_version();
}
const ::std::string& PacketRequst::version() const {
  // @@protoc_insertion_point(field_get:p2p.PacketRequst.version)
  return version_.GetNoArena();
}
void PacketRequst::set_version(const ::std::string& value) {
  set_has_version();
  version_.SetNoArena(&PacketRequst::_default_version_.get(), value);
  // @@protoc_insertion_point(field_set:p2p.PacketRequst.version)
}
#if LANG_CXX11
void PacketRequst::set_version(::std::string&& value) {
  set_has_version();
  version_.SetNoArena(
    &PacketRequst::_default_version_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:p2p.PacketRequst.version)
}
#endif
void PacketRequst::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_version();
  version_.SetNoArena(&PacketRequst::_default_version_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:p2p.PacketRequst.version)
}
void PacketRequst::set_version(const char* value, size_t size) {
  set_has_version();
  version_.SetNoArena(&PacketRequst::_default_version_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:p2p.PacketRequst.version)
}
::std::string* PacketRequst::mutable_version() {
  set_has_version();
  // @@protoc_insertion_point(field_mutable:p2p.PacketRequst.version)
  return version_.MutableNoArena(&PacketRequst::_default_version_.get());
}
::std::string* PacketRequst::release_version() {
  // @@protoc_insertion_point(field_release:p2p.PacketRequst.version)
  clear_has_version();
  return version_.ReleaseNoArena(&PacketRequst::_default_version_.get());
}
void PacketRequst::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    set_has_version();
  } else {
    clear_has_version();
  }
  version_.SetAllocatedNoArena(&PacketRequst::_default_version_.get(), version);
  // @@protoc_insertion_point(field_set_allocated:p2p.PacketRequst.version)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

::google::protobuf::internal::ExplicitlyConstructed< ::std::string> PacketRespond::_default_version_;
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PacketRespond::kRpcApiFieldNumber;
const int PacketRespond::kConnectRespondFieldNumber;
const int PacketRespond::kGetUsersOnlineRespondFieldNumber;
const int PacketRespond::kNotifyRespondFieldNumber;
const int PacketRespond::kHelloRespondFieldNumber;
const int PacketRespond::kVersionFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PacketRespond::PacketRespond()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_peer_2dto_2dpeer_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:p2p.PacketRespond)
}
PacketRespond::PacketRespond(const PacketRespond& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  version_.UnsafeSetDefault(&PacketRespond::_default_version_.get());
  if (from.has_version()) {
    version_.AssignWithDefault(&PacketRespond::_default_version_.get(), from.version_);
  }
  if (from.has_connectrespond()) {
    connectrespond_ = new ::p2p::ConnectRespond(*from.connectrespond_);
  } else {
    connectrespond_ = NULL;
  }
  if (from.has_getusersonlinerespond()) {
    getusersonlinerespond_ = new ::p2p::GetUsersOnlineRespond(*from.getusersonlinerespond_);
  } else {
    getusersonlinerespond_ = NULL;
  }
  if (from.has_notifyrespond()) {
    notifyrespond_ = new ::p2p::NotifyRespond(*from.notifyrespond_);
  } else {
    notifyrespond_ = NULL;
  }
  if (from.has_hellorespond()) {
    hellorespond_ = new ::p2p::HelloRespond(*from.hellorespond_);
  } else {
    hellorespond_ = NULL;
  }
  rpcapi_ = from.rpcapi_;
  // @@protoc_insertion_point(copy_constructor:p2p.PacketRespond)
}

void PacketRespond::SharedCtor() {
  _cached_size_ = 0;
  version_.UnsafeSetDefault(&PacketRespond::_default_version_.get());
  ::memset(&connectrespond_, 0, reinterpret_cast<char*>(&hellorespond_) -
    reinterpret_cast<char*>(&connectrespond_) + sizeof(hellorespond_));
  rpcapi_ = 1;
}

PacketRespond::~PacketRespond() {
  // @@protoc_insertion_point(destructor:p2p.PacketRespond)
  SharedDtor();
}

void PacketRespond::SharedDtor() {
  version_.DestroyNoArena(&PacketRespond::_default_version_.get());
  if (this != internal_default_instance()) {
    delete connectrespond_;
  }
  if (this != internal_default_instance()) {
    delete getusersonlinerespond_;
  }
  if (this != internal_default_instance()) {
    delete notifyrespond_;
  }
  if (this != internal_default_instance()) {
    delete hellorespond_;
  }
}

void PacketRespond::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PacketRespond::descriptor() {
  protobuf_peer_2dto_2dpeer_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_peer_2dto_2dpeer_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const PacketRespond& PacketRespond::default_instance() {
  protobuf_peer_2dto_2dpeer_2eproto::InitDefaults();
  return *internal_default_instance();
}

PacketRespond* PacketRespond::New(::google::protobuf::Arena* arena) const {
  PacketRespond* n = new PacketRespond;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PacketRespond::Clear() {
// @@protoc_insertion_point(message_clear_start:p2p.PacketRespond)
  if (_has_bits_[0 / 32] & 63u) {
    if (has_version()) {
      GOOGLE_DCHECK(!version_.IsDefault(&PacketRespond::_default_version_.get()));
      (*version_.UnsafeRawStringPointer())->assign(*&PacketRespond::_default_version_.get());
    }
    if (has_connectrespond()) {
      GOOGLE_DCHECK(connectrespond_ != NULL);
      connectrespond_->::p2p::ConnectRespond::Clear();
    }
    if (has_getusersonlinerespond()) {
      GOOGLE_DCHECK(getusersonlinerespond_ != NULL);
      getusersonlinerespond_->::p2p::GetUsersOnlineRespond::Clear();
    }
    if (has_notifyrespond()) {
      GOOGLE_DCHECK(notifyrespond_ != NULL);
      notifyrespond_->::p2p::NotifyRespond::Clear();
    }
    if (has_hellorespond()) {
      GOOGLE_DCHECK(hellorespond_ != NULL);
      hellorespond_->::p2p::HelloRespond::Clear();
    }
    rpcapi_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool PacketRespond::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:p2p.PacketRespond)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .p2p.RPCAPI rpcApi = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::p2p::RPCAPI_IsValid(value)) {
            set_rpcapi(static_cast< ::p2p::RPCAPI >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .p2p.ConnectRespond connectRespond = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_connectrespond()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .p2p.GetUsersOnlineRespond getUsersOnlineRespond = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_getusersonlinerespond()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .p2p.NotifyRespond notifyRespond = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_notifyrespond()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .p2p.HelloRespond helloRespond = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_hellorespond()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string version = 6 [default = "0.1.0"];
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(50u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_version()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->version().data(), this->version().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "p2p.PacketRespond.version");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:p2p.PacketRespond)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:p2p.PacketRespond)
  return false;
#undef DO_
}

void PacketRespond::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:p2p.PacketRespond)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .p2p.RPCAPI rpcApi = 1;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->rpcapi(), output);
  }

  // optional .p2p.ConnectRespond connectRespond = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->connectrespond_, output);
  }

  // optional .p2p.GetUsersOnlineRespond getUsersOnlineRespond = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->getusersonlinerespond_, output);
  }

  // optional .p2p.NotifyRespond notifyRespond = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->notifyrespond_, output);
  }

  // optional .p2p.HelloRespond helloRespond = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *this->hellorespond_, output);
  }

  // optional string version = 6 [default = "0.1.0"];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "p2p.PacketRespond.version");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->version(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:p2p.PacketRespond)
}

::google::protobuf::uint8* PacketRespond::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2p.PacketRespond)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .p2p.RPCAPI rpcApi = 1;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->rpcapi(), target);
  }

  // optional .p2p.ConnectRespond connectRespond = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->connectrespond_, deterministic, target);
  }

  // optional .p2p.GetUsersOnlineRespond getUsersOnlineRespond = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->getusersonlinerespond_, deterministic, target);
  }

  // optional .p2p.NotifyRespond notifyRespond = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *this->notifyrespond_, deterministic, target);
  }

  // optional .p2p.HelloRespond helloRespond = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        5, *this->hellorespond_, deterministic, target);
  }

  // optional string version = 6 [default = "0.1.0"];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "p2p.PacketRespond.version");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->version(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2p.PacketRespond)
  return target;
}

size_t PacketRespond::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2p.PacketRespond)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // required .p2p.RPCAPI rpcApi = 1;
  if (has_rpcapi()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->rpcapi());
  }
  if (_has_bits_[0 / 32] & 31u) {
    // optional string version = 6 [default = "0.1.0"];
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->version());
    }

    // optional .p2p.ConnectRespond connectRespond = 2;
    if (has_connectrespond()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->connectrespond_);
    }

    // optional .p2p.GetUsersOnlineRespond getUsersOnlineRespond = 3;
    if (has_getusersonlinerespond()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->getusersonlinerespond_);
    }

    // optional .p2p.NotifyRespond notifyRespond = 4;
    if (has_notifyrespond()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->notifyrespond_);
    }

    // optional .p2p.HelloRespond helloRespond = 5;
    if (has_hellorespond()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->hellorespond_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PacketRespond::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:p2p.PacketRespond)
  GOOGLE_DCHECK_NE(&from, this);
  const PacketRespond* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const PacketRespond>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:p2p.PacketRespond)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:p2p.PacketRespond)
    MergeFrom(*source);
  }
}

void PacketRespond::MergeFrom(const PacketRespond& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:p2p.PacketRespond)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 63u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_version();
      version_.AssignWithDefault(&PacketRespond::_default_version_.get(), from.version_);
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_connectrespond()->::p2p::ConnectRespond::MergeFrom(from.connectrespond());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_getusersonlinerespond()->::p2p::GetUsersOnlineRespond::MergeFrom(from.getusersonlinerespond());
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_notifyrespond()->::p2p::NotifyRespond::MergeFrom(from.notifyrespond());
    }
    if (cached_has_bits & 0x00000010u) {
      mutable_hellorespond()->::p2p::HelloRespond::MergeFrom(from.hellorespond());
    }
    if (cached_has_bits & 0x00000020u) {
      rpcapi_ = from.rpcapi_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void PacketRespond::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:p2p.PacketRespond)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PacketRespond::CopyFrom(const PacketRespond& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2p.PacketRespond)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PacketRespond::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000020) != 0x00000020) return false;
  if (has_connectrespond()) {
    if (!this->connectrespond_->IsInitialized()) return false;
  }
  if (has_notifyrespond()) {
    if (!this->notifyrespond_->IsInitialized()) return false;
  }
  if (has_hellorespond()) {
    if (!this->hellorespond_->IsInitialized()) return false;
  }
  return true;
}

void PacketRespond::Swap(PacketRespond* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PacketRespond::InternalSwap(PacketRespond* other) {
  version_.Swap(&other->version_);
  std::swap(connectrespond_, other->connectrespond_);
  std::swap(getusersonlinerespond_, other->getusersonlinerespond_);
  std::swap(notifyrespond_, other->notifyrespond_);
  std::swap(hellorespond_, other->hellorespond_);
  std::swap(rpcapi_, other->rpcapi_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata PacketRespond::GetMetadata() const {
  protobuf_peer_2dto_2dpeer_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_peer_2dto_2dpeer_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// PacketRespond

// required .p2p.RPCAPI rpcApi = 1;
bool PacketRespond::has_rpcapi() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void PacketRespond::set_has_rpcapi() {
  _has_bits_[0] |= 0x00000020u;
}
void PacketRespond::clear_has_rpcapi() {
  _has_bits_[0] &= ~0x00000020u;
}
void PacketRespond::clear_rpcapi() {
  rpcapi_ = 1;
  clear_has_rpcapi();
}
::p2p::RPCAPI PacketRespond::rpcapi() const {
  // @@protoc_insertion_point(field_get:p2p.PacketRespond.rpcApi)
  return static_cast< ::p2p::RPCAPI >(rpcapi_);
}
void PacketRespond::set_rpcapi(::p2p::RPCAPI value) {
  assert(::p2p::RPCAPI_IsValid(value));
  set_has_rpcapi();
  rpcapi_ = value;
  // @@protoc_insertion_point(field_set:p2p.PacketRespond.rpcApi)
}

// optional .p2p.ConnectRespond connectRespond = 2;
bool PacketRespond::has_connectrespond() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void PacketRespond::set_has_connectrespond() {
  _has_bits_[0] |= 0x00000002u;
}
void PacketRespond::clear_has_connectrespond() {
  _has_bits_[0] &= ~0x00000002u;
}
void PacketRespond::clear_connectrespond() {
  if (connectrespond_ != NULL) connectrespond_->::p2p::ConnectRespond::Clear();
  clear_has_connectrespond();
}
const ::p2p::ConnectRespond& PacketRespond::connectrespond() const {
  // @@protoc_insertion_point(field_get:p2p.PacketRespond.connectRespond)
  return connectrespond_ != NULL ? *connectrespond_
                         : *::p2p::ConnectRespond::internal_default_instance();
}
::p2p::ConnectRespond* PacketRespond::mutable_connectrespond() {
  set_has_connectrespond();
  if (connectrespond_ == NULL) {
    connectrespond_ = new ::p2p::ConnectRespond;
  }
  // @@protoc_insertion_point(field_mutable:p2p.PacketRespond.connectRespond)
  return connectrespond_;
}
::p2p::ConnectRespond* PacketRespond::release_connectrespond() {
  // @@protoc_insertion_point(field_release:p2p.PacketRespond.connectRespond)
  clear_has_connectrespond();
  ::p2p::ConnectRespond* temp = connectrespond_;
  connectrespond_ = NULL;
  return temp;
}
void PacketRespond::set_allocated_connectrespond(::p2p::ConnectRespond* connectrespond) {
  delete connectrespond_;
  connectrespond_ = connectrespond;
  if (connectrespond) {
    set_has_connectrespond();
  } else {
    clear_has_connectrespond();
  }
  // @@protoc_insertion_point(field_set_allocated:p2p.PacketRespond.connectRespond)
}

// optional .p2p.GetUsersOnlineRespond getUsersOnlineRespond = 3;
bool PacketRespond::has_getusersonlinerespond() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void PacketRespond::set_has_getusersonlinerespond() {
  _has_bits_[0] |= 0x00000004u;
}
void PacketRespond::clear_has_getusersonlinerespond() {
  _has_bits_[0] &= ~0x00000004u;
}
void PacketRespond::clear_getusersonlinerespond() {
  if (getusersonlinerespond_ != NULL) getusersonlinerespond_->::p2p::GetUsersOnlineRespond::Clear();
  clear_has_getusersonlinerespond();
}
const ::p2p::GetUsersOnlineRespond& PacketRespond::getusersonlinerespond() const {
  // @@protoc_insertion_point(field_get:p2p.PacketRespond.getUsersOnlineRespond)
  return getusersonlinerespond_ != NULL ? *getusersonlinerespond_
                         : *::p2p::GetUsersOnlineRespond::internal_default_instance();
}
::p2p::GetUsersOnlineRespond* PacketRespond::mutable_getusersonlinerespond() {
  set_has_getusersonlinerespond();
  if (getusersonlinerespond_ == NULL) {
    getusersonlinerespond_ = new ::p2p::GetUsersOnlineRespond;
  }
  // @@protoc_insertion_point(field_mutable:p2p.PacketRespond.getUsersOnlineRespond)
  return getusersonlinerespond_;
}
::p2p::GetUsersOnlineRespond* PacketRespond::release_getusersonlinerespond() {
  // @@protoc_insertion_point(field_release:p2p.PacketRespond.getUsersOnlineRespond)
  clear_has_getusersonlinerespond();
  ::p2p::GetUsersOnlineRespond* temp = getusersonlinerespond_;
  getusersonlinerespond_ = NULL;
  return temp;
}
void PacketRespond::set_allocated_getusersonlinerespond(::p2p::GetUsersOnlineRespond* getusersonlinerespond) {
  delete getusersonlinerespond_;
  getusersonlinerespond_ = getusersonlinerespond;
  if (getusersonlinerespond) {
    set_has_getusersonlinerespond();
  } else {
    clear_has_getusersonlinerespond();
  }
  // @@protoc_insertion_point(field_set_allocated:p2p.PacketRespond.getUsersOnlineRespond)
}

// optional .p2p.NotifyRespond notifyRespond = 4;
bool PacketRespond::has_notifyrespond() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void PacketRespond::set_has_notifyrespond() {
  _has_bits_[0] |= 0x00000008u;
}
void PacketRespond::clear_has_notifyrespond() {
  _has_bits_[0] &= ~0x00000008u;
}
void PacketRespond::clear_notifyrespond() {
  if (notifyrespond_ != NULL) notifyrespond_->::p2p::NotifyRespond::Clear();
  clear_has_notifyrespond();
}
const ::p2p::NotifyRespond& PacketRespond::notifyrespond() const {
  // @@protoc_insertion_point(field_get:p2p.PacketRespond.notifyRespond)
  return notifyrespond_ != NULL ? *notifyrespond_
                         : *::p2p::NotifyRespond::internal_default_instance();
}
::p2p::NotifyRespond* PacketRespond::mutable_notifyrespond() {
  set_has_notifyrespond();
  if (notifyrespond_ == NULL) {
    notifyrespond_ = new ::p2p::NotifyRespond;
  }
  // @@protoc_insertion_point(field_mutable:p2p.PacketRespond.notifyRespond)
  return notifyrespond_;
}
::p2p::NotifyRespond* PacketRespond::release_notifyrespond() {
  // @@protoc_insertion_point(field_release:p2p.PacketRespond.notifyRespond)
  clear_has_notifyrespond();
  ::p2p::NotifyRespond* temp = notifyrespond_;
  notifyrespond_ = NULL;
  return temp;
}
void PacketRespond::set_allocated_notifyrespond(::p2p::NotifyRespond* notifyrespond) {
  delete notifyrespond_;
  notifyrespond_ = notifyrespond;
  if (notifyrespond) {
    set_has_notifyrespond();
  } else {
    clear_has_notifyrespond();
  }
  // @@protoc_insertion_point(field_set_allocated:p2p.PacketRespond.notifyRespond)
}

// optional .p2p.HelloRespond helloRespond = 5;
bool PacketRespond::has_hellorespond() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void PacketRespond::set_has_hellorespond() {
  _has_bits_[0] |= 0x00000010u;
}
void PacketRespond::clear_has_hellorespond() {
  _has_bits_[0] &= ~0x00000010u;
}
void PacketRespond::clear_hellorespond() {
  if (hellorespond_ != NULL) hellorespond_->::p2p::HelloRespond::Clear();
  clear_has_hellorespond();
}
const ::p2p::HelloRespond& PacketRespond::hellorespond() const {
  // @@protoc_insertion_point(field_get:p2p.PacketRespond.helloRespond)
  return hellorespond_ != NULL ? *hellorespond_
                         : *::p2p::HelloRespond::internal_default_instance();
}
::p2p::HelloRespond* PacketRespond::mutable_hellorespond() {
  set_has_hellorespond();
  if (hellorespond_ == NULL) {
    hellorespond_ = new ::p2p::HelloRespond;
  }
  // @@protoc_insertion_point(field_mutable:p2p.PacketRespond.helloRespond)
  return hellorespond_;
}
::p2p::HelloRespond* PacketRespond::release_hellorespond() {
  // @@protoc_insertion_point(field_release:p2p.PacketRespond.helloRespond)
  clear_has_hellorespond();
  ::p2p::HelloRespond* temp = hellorespond_;
  hellorespond_ = NULL;
  return temp;
}
void PacketRespond::set_allocated_hellorespond(::p2p::HelloRespond* hellorespond) {
  delete hellorespond_;
  hellorespond_ = hellorespond;
  if (hellorespond) {
    set_has_hellorespond();
  } else {
    clear_has_hellorespond();
  }
  // @@protoc_insertion_point(field_set_allocated:p2p.PacketRespond.helloRespond)
}

// optional string version = 6 [default = "0.1.0"];
bool PacketRespond::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void PacketRespond::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
void PacketRespond::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
void PacketRespond::clear_version() {
  version_.ClearToDefaultNoArena(&PacketRespond::_default_version_.get());
  clear_has_version();
}
const ::std::string& PacketRespond::version() const {
  // @@protoc_insertion_point(field_get:p2p.PacketRespond.version)
  return version_.GetNoArena();
}
void PacketRespond::set_version(const ::std::string& value) {
  set_has_version();
  version_.SetNoArena(&PacketRespond::_default_version_.get(), value);
  // @@protoc_insertion_point(field_set:p2p.PacketRespond.version)
}
#if LANG_CXX11
void PacketRespond::set_version(::std::string&& value) {
  set_has_version();
  version_.SetNoArena(
    &PacketRespond::_default_version_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:p2p.PacketRespond.version)
}
#endif
void PacketRespond::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_version();
  version_.SetNoArena(&PacketRespond::_default_version_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:p2p.PacketRespond.version)
}
void PacketRespond::set_version(const char* value, size_t size) {
  set_has_version();
  version_.SetNoArena(&PacketRespond::_default_version_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:p2p.PacketRespond.version)
}
::std::string* PacketRespond::mutable_version() {
  set_has_version();
  // @@protoc_insertion_point(field_mutable:p2p.PacketRespond.version)
  return version_.MutableNoArena(&PacketRespond::_default_version_.get());
}
::std::string* PacketRespond::release_version() {
  // @@protoc_insertion_point(field_release:p2p.PacketRespond.version)
  clear_has_version();
  return version_.ReleaseNoArena(&PacketRespond::_default_version_.get());
}
void PacketRespond::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    set_has_version();
  } else {
    clear_has_version();
  }
  version_.SetAllocatedNoArena(&PacketRespond::_default_version_.get(), version);
  // @@protoc_insertion_point(field_set_allocated:p2p.PacketRespond.version)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Address::kIdFieldNumber;
const int Address::kAddressFieldNumber;
const int Address::kPortFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Address::Address()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_peer_2dto_2dpeer_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:p2p.Address)
}
Address::Address(const Address& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  address_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_address()) {
    address_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.address_);
  }
  id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_id()) {
    id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.id_);
  }
  port_ = from.port_;
  // @@protoc_insertion_point(copy_constructor:p2p.Address)
}

void Address::SharedCtor() {
  _cached_size_ = 0;
  address_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  port_ = 0;
}

Address::~Address() {
  // @@protoc_insertion_point(destructor:p2p.Address)
  SharedDtor();
}

void Address::SharedDtor() {
  address_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void Address::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Address::descriptor() {
  protobuf_peer_2dto_2dpeer_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_peer_2dto_2dpeer_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Address& Address::default_instance() {
  protobuf_peer_2dto_2dpeer_2eproto::InitDefaults();
  return *internal_default_instance();
}

Address* Address::New(::google::protobuf::Arena* arena) const {
  Address* n = new Address;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Address::Clear() {
// @@protoc_insertion_point(message_clear_start:p2p.Address)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_address()) {
      GOOGLE_DCHECK(!address_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*address_.UnsafeRawStringPointer())->clear();
    }
    if (has_id()) {
      GOOGLE_DCHECK(!id_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*id_.UnsafeRawStringPointer())->clear();
    }
  }
  port_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Address::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:p2p.Address)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string address = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_address()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->address().data(), this->address().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "p2p.Address.address");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 port = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u)) {
          set_has_port();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &port_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required string id = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_id()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->id().data(), this->id().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "p2p.Address.id");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:p2p.Address)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:p2p.Address)
  return false;
#undef DO_
}

void Address::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:p2p.Address)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string address = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->address().data(), this->address().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "p2p.Address.address");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->address(), output);
  }

  // required int32 port = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->port(), output);
  }

  // required string id = 4;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->id().data(), this->id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "p2p.Address.id");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->id(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:p2p.Address)
}

::google::protobuf::uint8* Address::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2p.Address)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string address = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->address().data(), this->address().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "p2p.Address.address");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->address(), target);
  }

  // required int32 port = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->port(), target);
  }

  // required string id = 4;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->id().data(), this->id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "p2p.Address.id");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->id(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2p.Address)
  return target;
}

size_t Address::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:p2p.Address)
  size_t total_size = 0;

  if (has_address()) {
    // required string address = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->address());
  }

  if (has_id()) {
    // required string id = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->id());
  }

  if (has_port()) {
    // required int32 port = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->port());
  }

  return total_size;
}
size_t Address::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2p.Address)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string address = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->address());

    // required string id = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->id());

    // required int32 port = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->port());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Address::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:p2p.Address)
  GOOGLE_DCHECK_NE(&from, this);
  const Address* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Address>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:p2p.Address)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:p2p.Address)
    MergeFrom(*source);
  }
}

void Address::MergeFrom(const Address& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:p2p.Address)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_address();
      address_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.address_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_id();
      id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.id_);
    }
    if (cached_has_bits & 0x00000004u) {
      port_ = from.port_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Address::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:p2p.Address)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Address::CopyFrom(const Address& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2p.Address)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Address::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  return true;
}

void Address::Swap(Address* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Address::InternalSwap(Address* other) {
  address_.Swap(&other->address_);
  id_.Swap(&other->id_);
  std::swap(port_, other->port_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Address::GetMetadata() const {
  protobuf_peer_2dto_2dpeer_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_peer_2dto_2dpeer_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Address

// required string id = 4;
bool Address::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Address::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
void Address::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
void Address::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
const ::std::string& Address::id() const {
  // @@protoc_insertion_point(field_get:p2p.Address.id)
  return id_.GetNoArena();
}
void Address::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:p2p.Address.id)
}
#if LANG_CXX11
void Address::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:p2p.Address.id)
}
#endif
void Address::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:p2p.Address.id)
}
void Address::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:p2p.Address.id)
}
::std::string* Address::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:p2p.Address.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* Address::release_id() {
  // @@protoc_insertion_point(field_release:p2p.Address.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void Address::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:p2p.Address.id)
}

// required string address = 2;
bool Address::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Address::set_has_address() {
  _has_bits_[0] |= 0x00000001u;
}
void Address::clear_has_address() {
  _has_bits_[0] &= ~0x00000001u;
}
void Address::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_address();
}
const ::std::string& Address::address() const {
  // @@protoc_insertion_point(field_get:p2p.Address.address)
  return address_.GetNoArena();
}
void Address::set_address(const ::std::string& value) {
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:p2p.Address.address)
}
#if LANG_CXX11
void Address::set_address(::std::string&& value) {
  set_has_address();
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:p2p.Address.address)
}
#endif
void Address::set_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:p2p.Address.address)
}
void Address::set_address(const char* value, size_t size) {
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:p2p.Address.address)
}
::std::string* Address::mutable_address() {
  set_has_address();
  // @@protoc_insertion_point(field_mutable:p2p.Address.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* Address::release_address() {
  // @@protoc_insertion_point(field_release:p2p.Address.address)
  clear_has_address();
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void Address::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    set_has_address();
  } else {
    clear_has_address();
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:p2p.Address.address)
}

// required int32 port = 3;
bool Address::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Address::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
void Address::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
void Address::clear_port() {
  port_ = 0;
  clear_has_port();
}
::google::protobuf::int32 Address::port() const {
  // @@protoc_insertion_point(field_get:p2p.Address.port)
  return port_;
}
void Address::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:p2p.Address.port)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

::google::protobuf::internal::ExplicitlyConstructed< ::std::string> Message::_default_version_;
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Message::kTFieldNumber;
const int Message::kAddressFieldNumber;
const int Message::kVersionFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Message::Message()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_peer_2dto_2dpeer_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:p2p.Message)
}
Message::Message(const Message& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  version_.UnsafeSetDefault(&Message::_default_version_.get());
  if (from.has_version()) {
    version_.AssignWithDefault(&Message::_default_version_.get(), from.version_);
  }
  if (from.has_address()) {
    address_ = new ::p2p::Address(*from.address_);
  } else {
    address_ = NULL;
  }
  t_ = from.t_;
  // @@protoc_insertion_point(copy_constructor:p2p.Message)
}

void Message::SharedCtor() {
  _cached_size_ = 0;
  version_.UnsafeSetDefault(&Message::_default_version_.get());
  address_ = NULL;
  t_ = 1;
}

Message::~Message() {
  // @@protoc_insertion_point(destructor:p2p.Message)
  SharedDtor();
}

void Message::SharedDtor() {
  version_.DestroyNoArena(&Message::_default_version_.get());
  if (this != internal_default_instance()) {
    delete address_;
  }
}

void Message::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Message::descriptor() {
  protobuf_peer_2dto_2dpeer_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_peer_2dto_2dpeer_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Message& Message::default_instance() {
  protobuf_peer_2dto_2dpeer_2eproto::InitDefaults();
  return *internal_default_instance();
}

Message* Message::New(::google::protobuf::Arena* arena) const {
  Message* n = new Message;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Message::Clear() {
// @@protoc_insertion_point(message_clear_start:p2p.Message)
  if (_has_bits_[0 / 32] & 7u) {
    if (has_version()) {
      GOOGLE_DCHECK(!version_.IsDefault(&Message::_default_version_.get()));
      (*version_.UnsafeRawStringPointer())->assign(*&Message::_default_version_.get());
    }
    if (has_address()) {
      GOOGLE_DCHECK(address_ != NULL);
      address_->::p2p::Address::Clear();
    }
    t_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Message::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:p2p.Message)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .p2p.MessageType t = 1 [default = ADDRESS];
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::p2p::MessageType_IsValid(value)) {
            set_t(static_cast< ::p2p::MessageType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .p2p.Address address = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_address()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string version = 3 [default = "0.1.0"];
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_version()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->version().data(), this->version().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "p2p.Message.version");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:p2p.Message)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:p2p.Message)
  return false;
#undef DO_
}

void Message::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:p2p.Message)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .p2p.MessageType t = 1 [default = ADDRESS];
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->t(), output);
  }

  // optional .p2p.Address address = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->address_, output);
  }

  // optional string version = 3 [default = "0.1.0"];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "p2p.Message.version");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->version(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:p2p.Message)
}

::google::protobuf::uint8* Message::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2p.Message)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .p2p.MessageType t = 1 [default = ADDRESS];
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->t(), target);
  }

  // optional .p2p.Address address = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->address_, deterministic, target);
  }

  // optional string version = 3 [default = "0.1.0"];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "p2p.Message.version");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->version(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2p.Message)
  return target;
}

size_t Message::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2p.Message)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // required .p2p.MessageType t = 1 [default = ADDRESS];
  if (has_t()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->t());
  }
  if (_has_bits_[0 / 32] & 3u) {
    // optional string version = 3 [default = "0.1.0"];
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->version());
    }

    // optional .p2p.Address address = 2;
    if (has_address()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->address_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Message::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:p2p.Message)
  GOOGLE_DCHECK_NE(&from, this);
  const Message* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Message>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:p2p.Message)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:p2p.Message)
    MergeFrom(*source);
  }
}

void Message::MergeFrom(const Message& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:p2p.Message)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_version();
      version_.AssignWithDefault(&Message::_default_version_.get(), from.version_);
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_address()->::p2p::Address::MergeFrom(from.address());
    }
    if (cached_has_bits & 0x00000004u) {
      t_ = from.t_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Message::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:p2p.Message)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Message::CopyFrom(const Message& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2p.Message)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Message::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000004) != 0x00000004) return false;
  if (has_address()) {
    if (!this->address_->IsInitialized()) return false;
  }
  return true;
}

void Message::Swap(Message* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Message::InternalSwap(Message* other) {
  version_.Swap(&other->version_);
  std::swap(address_, other->address_);
  std::swap(t_, other->t_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Message::GetMetadata() const {
  protobuf_peer_2dto_2dpeer_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_peer_2dto_2dpeer_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Message

// required .p2p.MessageType t = 1 [default = ADDRESS];
bool Message::has_t() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Message::set_has_t() {
  _has_bits_[0] |= 0x00000004u;
}
void Message::clear_has_t() {
  _has_bits_[0] &= ~0x00000004u;
}
void Message::clear_t() {
  t_ = 1;
  clear_has_t();
}
::p2p::MessageType Message::t() const {
  // @@protoc_insertion_point(field_get:p2p.Message.t)
  return static_cast< ::p2p::MessageType >(t_);
}
void Message::set_t(::p2p::MessageType value) {
  assert(::p2p::MessageType_IsValid(value));
  set_has_t();
  t_ = value;
  // @@protoc_insertion_point(field_set:p2p.Message.t)
}

// optional .p2p.Address address = 2;
bool Message::has_address() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Message::set_has_address() {
  _has_bits_[0] |= 0x00000002u;
}
void Message::clear_has_address() {
  _has_bits_[0] &= ~0x00000002u;
}
void Message::clear_address() {
  if (address_ != NULL) address_->::p2p::Address::Clear();
  clear_has_address();
}
const ::p2p::Address& Message::address() const {
  // @@protoc_insertion_point(field_get:p2p.Message.address)
  return address_ != NULL ? *address_
                         : *::p2p::Address::internal_default_instance();
}
::p2p::Address* Message::mutable_address() {
  set_has_address();
  if (address_ == NULL) {
    address_ = new ::p2p::Address;
  }
  // @@protoc_insertion_point(field_mutable:p2p.Message.address)
  return address_;
}
::p2p::Address* Message::release_address() {
  // @@protoc_insertion_point(field_release:p2p.Message.address)
  clear_has_address();
  ::p2p::Address* temp = address_;
  address_ = NULL;
  return temp;
}
void Message::set_allocated_address(::p2p::Address* address) {
  delete address_;
  address_ = address;
  if (address) {
    set_has_address();
  } else {
    clear_has_address();
  }
  // @@protoc_insertion_point(field_set_allocated:p2p.Message.address)
}

// optional string version = 3 [default = "0.1.0"];
bool Message::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Message::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
void Message::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
void Message::clear_version() {
  version_.ClearToDefaultNoArena(&Message::_default_version_.get());
  clear_has_version();
}
const ::std::string& Message::version() const {
  // @@protoc_insertion_point(field_get:p2p.Message.version)
  return version_.GetNoArena();
}
void Message::set_version(const ::std::string& value) {
  set_has_version();
  version_.SetNoArena(&Message::_default_version_.get(), value);
  // @@protoc_insertion_point(field_set:p2p.Message.version)
}
#if LANG_CXX11
void Message::set_version(::std::string&& value) {
  set_has_version();
  version_.SetNoArena(
    &Message::_default_version_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:p2p.Message.version)
}
#endif
void Message::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_version();
  version_.SetNoArena(&Message::_default_version_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:p2p.Message.version)
}
void Message::set_version(const char* value, size_t size) {
  set_has_version();
  version_.SetNoArena(&Message::_default_version_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:p2p.Message.version)
}
::std::string* Message::mutable_version() {
  set_has_version();
  // @@protoc_insertion_point(field_mutable:p2p.Message.version)
  return version_.MutableNoArena(&Message::_default_version_.get());
}
::std::string* Message::release_version() {
  // @@protoc_insertion_point(field_release:p2p.Message.version)
  clear_has_version();
  return version_.ReleaseNoArena(&Message::_default_version_.get());
}
void Message::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    set_has_version();
  } else {
    clear_has_version();
  }
  version_.SetAllocatedNoArena(&Message::_default_version_.get(), version);
  // @@protoc_insertion_point(field_set_allocated:p2p.Message.version)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace p2p

// @@protoc_insertion_point(global_scope)
